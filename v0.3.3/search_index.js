var documenterSearchIndex = {"docs":
[{"location":"man/quick_start/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"man/quick_start/","page":"Quick Start","title":"Quick Start","text":"CurrentModule = SatelliteToolboxPropagators","category":"page"},{"location":"man/quick_start/","page":"Quick Start","title":"Quick Start","text":"using SatelliteToolboxPropagators","category":"page"},{"location":"man/quick_start/","page":"Quick Start","title":"Quick Start","text":"Let's suppose we want to discover the ISS position on May 19, 2013, at 12:00:00. First, we need to obtain a description of its orbit and use the corresponding propagator. Using the Celestrak service, for example, we can obtain the ISS TLE on May 18, 2023:","category":"page"},{"location":"man/quick_start/","page":"Quick Start","title":"Quick Start","text":"ISS (ZARYA)             \n1 25544U 98067A   23138.86946505 -.00404279  00000+0 -74572-2 0  9994\n2 25544  51.6431 113.8899 0006661 357.1286  88.0982 15.49924990397244","category":"page"},{"location":"man/quick_start/","page":"Quick Start","title":"Quick Start","text":"Since we have a TLE, we must use the SGP4/SDP4 propagator. Let's initialize the algorithm first:","category":"page"},{"location":"man/quick_start/","page":"Quick Start","title":"Quick Start","text":"iss_tle = tle\"\"\"\n    ISS (ZARYA)\n    1 25544U 98067A   23138.86946505 -.00404279  00000+0 -74572-2 0  9994\n    2 25544  51.6431 113.8899 0006661 357.1286  88.0982 15.49924990397244\"\"\"\n\norbp = Propagators.init(Val(:SGP4), iss_tle)","category":"page"},{"location":"man/quick_start/","page":"Quick Start","title":"Quick Start","text":"Now we can propagate the ISS orbit to the desired epoch and obtain its state vector and mean elements:","category":"page"},{"location":"man/quick_start/","page":"Quick Start","title":"Quick Start","text":"Propagators.propagate_to_epoch!(orbp, date_to_jd(2023, 5, 19, 12, 0, 0))\n\nPropagators.mean_elements(orbp)","category":"page"},{"location":"man/quick_start/","page":"Quick Start","title":"Quick Start","text":"note: Note\nSince we are using a TLE, the state vector is represented in the TEME reference frame.","category":"page"},{"location":"man/API/#API","page":"API","title":"API","text":"","category":"section"},{"location":"man/API/","page":"API","title":"API","text":"SatelliteToolboxPropagators.jl has a propagator API to improve the usability. This API has the following requirements, which must be met by all propagators that uses it.","category":"page"},{"location":"man/API/","page":"API","title":"API","text":"Every propagator must have a structure derived from OrbitPropagator with the following requirement:","category":"page"},{"location":"man/API/","page":"API","title":"API","text":"struct OrbitPropagator<Propagator name>{Tepoch, T} <: OrbitPropagator{Tepoch, T}\n    <Any field required by the propagator>\nend","category":"page"},{"location":"man/API/","page":"API","title":"API","text":"where Tepoch is the type used to represent the epoch of the input elements, whereas T is the type used for the internal variables.","category":"page"},{"location":"man/API/#Initialization","page":"API","title":"Initialization","text":"","category":"section"},{"location":"man/API/","page":"API","title":"API","text":"The initialization is performed by the function:","category":"page"},{"location":"man/API/","page":"API","title":"API","text":"Propagators.init(T, args...; kwargs...)","category":"page"},{"location":"man/API/","page":"API","title":"API","text":"where T = Val(<Orbit propagator symbol>), and it must return and object of type OrbitPropagator<Propagator name>. The arguments and keywords depends on the propagator and must be documented in the docstring. The propagator must record the epoch during the initialization, which must be kept constant during the entire object existence. It also needs to record the instant of the last propagation.","category":"page"},{"location":"man/API/#Epoch","page":"API","title":"Epoch","text":"","category":"section"},{"location":"man/API/","page":"API","title":"API","text":"Each propagator must return the initial element epoch in Julian Day by the function:","category":"page"},{"location":"man/API/","page":"API","title":"API","text":"Propagators.epoch(orbp)","category":"page"},{"location":"man/API/","page":"API","title":"API","text":"Notice that this value must never change during the existence of the object orbp.","category":"page"},{"location":"man/API/#Last-Instant","page":"API","title":"Last Instant","text":"","category":"section"},{"location":"man/API/","page":"API","title":"API","text":"Each propagator must return the last propagation instant [s] measured from the epoch. This action must be performed by the function:","category":"page"},{"location":"man/API/","page":"API","title":"API","text":"Propagators.last_instant(orbp)","category":"page"},{"location":"man/API/#Propagation","page":"API","title":"Propagation","text":"","category":"section"},{"location":"man/API/","page":"API","title":"API","text":"The following functions must be overloaded by each propagator.","category":"page"},{"location":"man/API/","page":"API","title":"API","text":"Propagators.propagate!(orbp, t)","category":"page"},{"location":"man/API/","page":"API","title":"API","text":"Propagate the orbit of propagator orbp by t [s] from the epoch. This function must return the propagated position and velocity represented in the same reference frame used in the initialization. The output vector must use the SI.","category":"page"},{"location":"man/API/","page":"API","title":"API","text":"Propagators.step!(orbp, dt)","category":"page"},{"location":"man/API/","page":"API","title":"API","text":"Propagate the orbit of propagator orbp by dt [s] from the instant of the last propagation. This function must return the propagated position and velocity represented in the same reference frame used in the initialization. The output vector must use the SI.","category":"page"},{"location":"man/API/","page":"API","title":"API","text":"Note The API provides a default implementation for Propagators.step!. Hence, strictly speaking, only the implementation of Propagators.propagate! is required for the API. However, there are some cases in which it is more accurate to implement Propagators.step! and use this algorithm to build the function Propagators.propagate!. In those cases, the user must overload both functions.","category":"page"},{"location":"man/API/","page":"API","title":"API","text":"We also have the function Propagators.propagate_to_epoch!, but the default implementation should work for all propagators.","category":"page"},{"location":"man/API/#In-place-initialization-(Optional)","page":"API","title":"In-place initialization (Optional)","text":"","category":"section"},{"location":"man/API/","page":"API","title":"API","text":"If the propagator supports in-place initialization, it must overload the following function:","category":"page"},{"location":"man/API/","page":"API","title":"API","text":"Propagators.init!(orbp::OrbitPropagator<Propagator name>, args...; kwargs...)","category":"page"},{"location":"man/API/#Mean-Elements-(Optional)","page":"API","title":"Mean Elements (Optional)","text":"","category":"section"},{"location":"man/API/","page":"API","title":"API","text":"The function","category":"page"},{"location":"man/API/","page":"API","title":"API","text":"Propagators.mean_elements(orbp)","category":"page"},{"location":"man/API/","page":"API","title":"API","text":"should return the mean elements using the structure KeplerianElements related to the latest propagation. Notice that this is an optional feature. If the propagator does not implement it, it will return nothing.","category":"page"},{"location":"man/API/#Name-(Optional)","page":"API","title":"Name (Optional)","text":"","category":"section"},{"location":"man/API/","page":"API","title":"API","text":"The propagator can overload the function:","category":"page"},{"location":"man/API/","page":"API","title":"API","text":"Propagators.name(orbp)","category":"page"},{"location":"man/API/","page":"API","title":"API","text":"to return its name. The system uses this information to display the object using the function show. If the function is not provided, the structure name is used by default.","category":"page"},{"location":"man/API/#Simultaneous-Initialization-and-Propagation-(Optional)","page":"API","title":"Simultaneous Initialization and Propagation (Optional)","text":"","category":"section"},{"location":"man/API/","page":"API","title":"API","text":"If the propagator supports, it can overload the functions:","category":"page"},{"location":"man/API/","page":"API","title":"API","text":"Propagators.propagate(t, args...; kwargs...)","category":"page"},{"location":"man/API/","page":"API","title":"API","text":"that simultaneously initialize and propagate the orbit to the instant t [s] after the input elements. args... and kwargs... must be the same as in the initialization function Propagators.init.","category":"page"},{"location":"man/API/#Fitting-Mean-Elements-(Optional)","page":"API","title":"Fitting Mean Elements (Optional)","text":"","category":"section"},{"location":"man/API/","page":"API","title":"API","text":"The propagator can implement the following functions to fit a set of osculating state vectors into mean elements for its theory:","category":"page"},{"location":"man/API/","page":"API","title":"API","text":"Propagators.fit_mean_elements(T, vjd::AbstractVector{Tjd}, vr_i::AbstractVector{Tv}, vv_i::AbstractVector{Tv}; kwargs...) where {Tjd<:Number, Tv<:AbstractVector}\nPropagators.fit_mean_elements!(orbp::OrbitPropagator<Propagator name>, vjd::AbstractVector{Tjd}, vr_i::AbstractVector{Tv}, vv_i::AbstractVector{Tv}; kwargs...) where {Tjd<:Number, Tv<:AbstractVector}","category":"page"},{"location":"man/API/","page":"API","title":"API","text":"where T = Val(<Orbit propagator symbol>), vr_i and vv_i are a set of position [m] and velocity [m / s] vectors obtained at the instants in vjd [Julian Day]. Those functions must return the mean elements used to initialize the propagator in the function Propagator.init.","category":"page"},{"location":"man/API/","page":"API","title":"API","text":"Each propagator type can define its own set of keyword arguments to configure the fitting process.","category":"page"},{"location":"man/API/","page":"API","title":"API","text":"The first signature will allocate a new propagator, whereas the second will use the allocated one passed as the first argument. In the latter, the propagator needs to be initialized with the fitted elements.","category":"page"},{"location":"man/propagators/j2/#J2_Propagator","page":"J2","title":"J2 Analytical Orbit Propagator","text":"","category":"section"},{"location":"man/propagators/j2/","page":"J2","title":"J2","text":"CurrentModule = SatelliteToolboxPropagators","category":"page"},{"location":"man/propagators/j2/","page":"J2","title":"J2","text":"using SatelliteToolboxPropagators","category":"page"},{"location":"man/propagators/j2/","page":"J2","title":"J2","text":"The J2 analytical orbit propagator considers only the J_2 perturbation term of the geopotential field to obtain a simple analytic solution for propagating the mean orbital elements. It has low precision but is extremely useful during mission design. For example, when designing a Sun-Synchronous orbit for a remote sensing mission, the satellite usually has a propulsion subsystem to maintain its orbit. Hence, the J2 propagator solution can be used as the nominal orbit through the mission lifetime to perform initial studies.","category":"page"},{"location":"man/propagators/j2/#Algorithm","page":"J2","title":"Algorithm","text":"","category":"section"},{"location":"man/propagators/j2/","page":"J2","title":"J2","text":"The algorithm implemented here is based on [1, 2]. This version takes into account only the secular effects in the orbit elements.","category":"page"},{"location":"man/propagators/j2/","page":"J2","title":"J2","text":"After neglecting all terms with higher order than J2, we obtain that only the right accession of the ascending node (RAAN), the argument of perigee, and mean motion are perturbed by the geopotential field with secular effects. Hence, the algorithm propagates the mean elements using the following equations:","category":"page"},{"location":"man/propagators/j2/","page":"J2","title":"J2","text":"beginaligned\n  p_0 = a_0 cdot (1 - e_0^2) \n  barn = n_0 cdot left1 + frac34 cdot J_2 cdot left(fracR_0p_0right)^2 cdot sqrt1 - e_0^2 cdot left(2 - 3sini_0^2right)right\n  Omega(t) = Omega_0 - frac23 cdot J_2 cdot left(fracR_0p_0right)^2 cdot barn cdot cosi_0 cdot left(t - t_0right) \n  omega(t) = omega_0 + frac34 cdot J_2 cdot left(fracR_0p_0right)^2 cdot barn cdot left(4 - 5sini_0^2right) cdot left(t - t_0right) \n  M(t) = M_0 + barn cdot left(t - t_0right) \nendaligned","category":"page"},{"location":"man/propagators/j2/","page":"J2","title":"J2","text":"where the subscript _0 indicates the initial element, t_0 is the initial mean elements' epoch, a is the mean semi-major axis, n_0 is mean motion, barn is the perturbed mean motion, e is the eccentricity, p is the semi-latus rectum, R_0 is the Earth's equatorial radius, Omega is the RAAN, and M is the mean anomaly.","category":"page"},{"location":"man/propagators/j2/#Initialization","page":"J2","title":"Initialization","text":"","category":"section"},{"location":"man/propagators/j2/","page":"J2","title":"J2","text":"We can initialize the J2 analytical orbit propagator with the following function:","category":"page"},{"location":"man/propagators/j2/","page":"J2","title":"J2","text":"Propagators.init(Val(:J2), orb₀::KeplerianElements; kwargs...) -> OrbitPropagatorJ2","category":"page"},{"location":"man/propagators/j2/","page":"J2","title":"J2","text":"which creates a J2 propagator structure OrbitPropagatorJ2 with the mean Keplerian elements orb₀.","category":"page"},{"location":"man/propagators/j2/","page":"J2","title":"J2","text":"The following keyword selects the gravitational constants for the propagation algorithm:","category":"page"},{"location":"man/propagators/j2/","page":"J2","title":"J2","text":"j2c::J2PropagatorConstants: J2 orbit propagator constants (see J2PropagatorConstants). (Default = j2c_egm2008)","category":"page"},{"location":"man/propagators/j2/","page":"J2","title":"J2","text":"This package contains some pre-built propagation constants for this propagator:","category":"page"},{"location":"man/propagators/j2/","page":"J2","title":"J2","text":"J2 Propagator Constant Description Type\nj2c_egm2008 EGM-2008 gravitational constants Float64\nj2c_egm2008_f32 EGM-2008 gravitational constants Float32\nj2c_egm1996 EGM-1996 gravitational constants Float64\nj2c_egm1996_f32 EGM-1996 gravitational constants Float32\nj2c_jgm02 JGM-02 gravitational constants Float64\nj2c_jgm02_f32 JGM-02 gravitational constants Float32\nj2c_jgm03 JGM-03 gravitational constants Float64\nj2c_jgm03_f32 JGM-03 gravitational constants Float32","category":"page"},{"location":"man/propagators/j2/","page":"J2","title":"J2","text":"note: Note\nThe type used in the propagation will be the same as used to define the constants in the structure j2c.","category":"page"},{"location":"man/propagators/j2/","page":"J2","title":"J2","text":"orb = KeplerianElements(\n    date_to_jd(2023, 1, 1, 0, 0, 0),\n    7190.982e3,\n    0.001111,\n    98.405 |> deg2rad,\n    100    |> deg2rad,\n    90     |> deg2rad,\n    19     |> deg2rad\n)\n\norbp = Propagators.init(Val(:J2), orb; j2c = j2c_jgm03)","category":"page"},{"location":"man/propagators/j2/#Fitting-Mean-Elements","page":"J2","title":"Fitting Mean Elements","text":"","category":"section"},{"location":"man/propagators/j2/","page":"J2","title":"J2","text":"We can use the function:","category":"page"},{"location":"man/propagators/j2/","page":"J2","title":"J2","text":"Propagators.fit_mean_elements(::Val{:J2}, vjd::AbstractVector{Tjd}, vr_i::AbstractVector{Tv}, vv_i::AbstractVector{Tv}; kwargs...) -> KeplerianElements{Float64, Float64}, SMatrix{6, 6, Float64}","category":"page"},{"location":"man/propagators/j2/","page":"J2","title":"J2","text":"to fit a set of mean Keplerian elements for the J2 orbit propagator using the osculating elements represented by a set of position vectors vr_i [m] and a set of velocity vectors vv_i [m / s] represented in an inertial reference frame at instants in the array vjd [Julian Day].","category":"page"},{"location":"man/propagators/j2/","page":"J2","title":"J2","text":"It returns the fitted Keplerian elements and the final covariance matrix of the least-square algorithm.","category":"page"},{"location":"man/propagators/j2/","page":"J2","title":"J2","text":"note: Note\nThis algorithm version will allocate a new J2 propagator with the default constants j2c_egm2008. If another set of constants are required, use the function Propagators.fit_mean_elements! instead.","category":"page"},{"location":"man/propagators/j2/","page":"J2","title":"J2","text":"The following keywords are available to configure the fitting process:","category":"page"},{"location":"man/propagators/j2/","page":"J2","title":"J2","text":"atol::Number: Tolerance for the residue absolute value. If the residue is lower than   atol at any iteration, the computation loop stops.   (Default = 2e-4)\nrtol::Number: Tolerance for the relative difference between the residues. If the   relative difference between the residues in two consecutive iterations is lower than   rtol, the computation loop stops.   (Default = 2e-4)\ninitial_guess::Union{Nothing, KeplerianElements}: Initial guess for the mean elements   fitting process. If it is nothing, the algorithm will obtain an initial estimate from   the osculating elements in vr_i and vv_i.   (Default = nothing)\njacobian_perturbation::Number: Initial state perturbation to compute the   finite-difference when calculating the Jacobian matrix.   (Default = 1e-3)\njacobian_perturbation_tol::Number: Tolerance to accept the perturbation when calculating   the Jacobian matrix. If the computed perturbation is lower than   jacobian_perturbation_tol, we increase it until it absolute value is higher than   jacobian_perturbation_tol.   (Default = 1e-7)\nmax_iterations::Int: Maximum number of iterations allowed for the least-square fitting.   (Default = 50)\nmean_elements_epoch::Number: Epoch for the fitted mean elements.   (Default = vjd[end])\nverbose::Bool: If true, the algorithm prints debugging information to stdout.   (Default = true)\nweight_vector::AbstractVector: Vector with the measurements weights for the least-square   algorithm. We assemble the weight matrix W as a diagonal matrix with the elements in   weight_vector at its diagonal.   (Default = @SVector(ones(Bool, 6)))","category":"page"},{"location":"man/propagators/j2/","page":"J2","title":"J2","text":"vr_i = [\n    [-6792.402703741442, 2192.6458461287293, 0.18851758695295118]  .* 1000,\n    [-1781.214419290065, 1619.7795321872854, 6707.771633846665]    .* 1000,\n    [ 5693.643675547716, -1192.342828671633, 4123.976025977494]    .* 1000,\n    [ 5291.613719530499, -2354.5417593130833, -4175.561367156414]  .* 1000,\n    [-2416.3705905186903, -268.74923235392623, -6715.411357310478] .* 1000,\n    [-6795.043410709359, 2184.4414321930635, -0.4327055325971031]  .* 1000,\n];\n\nvv_i = [\n    [0.3445760107690598, 1.0395135806993514, 7.393686131436984]    .* 1000,\n    [6.875680282038698, -1.864319399615942, 2.270603214569518]     .* 1000,\n    [3.8964090757666496, -2.1887896252945875, -5.9960180359219075] .* 1000,\n    [-4.470258022565413, 0.5119576359985208, -5.9608372367141635]  .* 1000,\n    [-6.647358060413909, 2.495415251255861, 2.292118747543002]     .* 1000,\n    [0.3427096905434428, 1.040125572862349, 7.3936887585116855]    .* 1000,\n];\n\nvjd = [\n    2.46002818657856e6\n    2.460028200467449e6\n    2.460028214356338e6\n    2.4600282282452267e6\n    2.4600282421341157e6\n    2.4600282560230047e6\n];\n\norb, P = Propagators.fit_mean_elements(Val(:J2), vjd, vr_i, vv_i)\n\norb","category":"page"},{"location":"man/propagators/j2/#References","page":"J2","title":"References","text":"","category":"section"},{"location":"man/propagators/j2/","page":"J2","title":"J2","text":"[1] Vallado, D. A (2013). Fundamentals of Astrodynamics and Applications. 4th ed. Microcosm Press, Hawthorn, CA, USA.\n[2] Kozai, Y (1959). The Motion of a Close Earth Satellite. The Astronomical Journal, v. 64, no. 1274, pp. 367 – 377.","category":"page"},{"location":"man/propagators/j4/#J4_Propagator","page":"J4","title":"J4 Analytical Orbit Propagator","text":"","category":"section"},{"location":"man/propagators/j4/","page":"J4","title":"J4","text":"CurrentModule = SatelliteToolboxPropagators","category":"page"},{"location":"man/propagators/j4/","page":"J4","title":"J4","text":"using SatelliteToolboxPropagators","category":"page"},{"location":"man/propagators/j4/","page":"J4","title":"J4","text":"The J4 analytical orbit propagator considers the perturbation caused by the terms J_2, J_2^2, and J_4. It is a slightly more precise version of the J2 analytical orbit propagator useful for mission design and analysis.","category":"page"},{"location":"man/propagators/j4/#Algorithm","page":"J4","title":"Algorithm","text":"","category":"section"},{"location":"man/propagators/j4/","page":"J4","title":"J4","text":"The algorithm implemented here is based on [1, 2]. This version takes into account only the secular effects in the orbit elements.","category":"page"},{"location":"man/propagators/j4/","page":"J4","title":"J4","text":"Considering only the terms J_2, J_2^2, and J_4, we obtain that only the right accession of the ascending node (RAAN), the argument of perigee, and mean motion are perturbed by the geopotential field with secular effects. Hence, the algorithm propagates the mean elements using the following equations:","category":"page"},{"location":"man/propagators/j4/","page":"J4","title":"J4","text":"beginaligned\n   p_0 = a_0 cdot (1 - e_0^2) \n   beta = sqrt1 - e_0^2 \n   barn = n_0 cdot left right \n     beginaligned\n      quad 1 + \n      quad frac 3  4  cdot J_2   cdot left(fracR_0p_0right)^2 cdot beta cdot (2 - 3 sin^2 i_0) + \n      quad frac 3128  cdot J_2^2 cdot left(fracR_0p_0right)^4 cdot beta cdot left(120 + 64beta - 40beta^2 + (-240 - 192beta + 40beta^2) sini_0^2 + (105 + 144beta + 25beta^2) sini_0^4right) -\n      quad frac45128  cdot J_4   cdot left(fracR_0p_0right)^4 cdot beta cdot e_0^2 cdot left(-8 + 40sini_0^2 - 35sini_0^4right)\n    endaligned \n   left right \n   Omega(t) = Omega_0 + left right \n     beginaligned\n      quad -frac 3 2  cdot barn cdot J_2   left(fracR_0p_0right)^2 cdot cos i_0 + \n      quad  frac 332  cdot barn cdot J_2^2 left(fracR_0p_0right)^4 cdot cos i_0 cdot left(-36 - 4e_0^2 + 48beta + (40 - 5e_0^2 - 72beta) sini_0^2right) + \n      quad  frac1532  cdot n_0     cdot J_4   left(fracR_0p_0right)^4 cdot cos i_0 cdot left(8 + 12e_0^2 - (14 + 21e_0^2) sini_0^2 right)\n    endaligned \n   left right cdot left(t - t_0right) \n   omega(t) = omega_0 + left right \n     beginaligned\n      quad frac 3  4  cdot barn cdot J_2   left(fracR_0p_0right)^2 cdot (4 - 5sin^2 i_0) + \n      quad frac 3128  cdot barn cdot J_2^2 left(fracR_0p_0right)^4 cdot left(384 + 96e_0^2 - 384beta + (-824 - 116e_0^2 + 1056beta) sini_0^2 + (430 - 5e_0^2 - 720beta) sini_0^4right) - \n      quad frac15 16  cdot n_0     cdot J_2^2 left(fracR_0p_0right)^4 cdot e_0^2 cdot cosi_0^4 -\n      quad frac15128  cdot n_0     cdot J_4   left(fracR_0p_0right)^4 cdot (64 + 72e_0^2 - (248 + 252e_0^2) sini_0^2 + (196 + 189e_0^2) sini_0^4) \n    endaligned \n   left right cdot left(t - t_0right) \n   M(t) = M_0 + barn cdot left(t - t_0right) \nendaligned","category":"page"},{"location":"man/propagators/j4/","page":"J4","title":"J4","text":"where the subscript _0 indicates the initial element, t_0 is the initial mean elements' epoch, a is the mean semi-major axis, n_0 is mean motion, barn is the perturbed mean motion, e is the eccentricity, p is the semi-latus rectum, R_0 is the Earth's equatorial radius, Omega is the RAAN, and M is the mean anomaly.","category":"page"},{"location":"man/propagators/j4/","page":"J4","title":"J4","text":"warning: Warning\nThis propagator provides the same results as the ANSYS STK® for all Keplerian elements except for the right ascension of the ascending node (RAAN). In this case, we would need to flip the sign of the J_4 perturbation term to obtain similar values. However, this modification does not seem right given the references [1] and [2], and the version implemented here leads to lower errors when fitting orbits. Hence, further investigation is required. For more information, see this issue.","category":"page"},{"location":"man/propagators/j4/#Initialization","page":"J4","title":"Initialization","text":"","category":"section"},{"location":"man/propagators/j4/","page":"J4","title":"J4","text":"We can initialize the J4 analytical orbit propagator with the following function:","category":"page"},{"location":"man/propagators/j4/","page":"J4","title":"J4","text":"Propagators.init(Val(:J4), orb₀::KeplerianElements; kwargs...) -> OrbitPropagatorJ4","category":"page"},{"location":"man/propagators/j4/","page":"J4","title":"J4","text":"which creates a J4 propagator structure OrbitPropagatorJ4 with the mean Keplerian elements orb₀.","category":"page"},{"location":"man/propagators/j4/","page":"J4","title":"J4","text":"The following keyword selects the gravitational constants for the propagation algorithm:","category":"page"},{"location":"man/propagators/j4/","page":"J4","title":"J4","text":"j4c::J4PropagatorConstants: J4 orbit propagator constants (see J4PropagatorConstants). (Default = j4c_egm2008)","category":"page"},{"location":"man/propagators/j4/","page":"J4","title":"J4","text":"This package contains some pre-built propagation constants for this propagator:","category":"page"},{"location":"man/propagators/j4/","page":"J4","title":"J4","text":"J4 Propagator Constant Description Type\nj4c_egm2008 EGM-2008 gravitational constants Float64\nj4c_egm2008_f32 EGM-2008 gravitational constants Float32\nj4c_egm1996 EGM-1996 gravitational constants Float64\nj4c_egm1996_f32 EGM-1996 gravitational constants Float32\nj4c_jgm02 JGM-02 gravitational constants Float64\nj4c_jgm02_f32 JGM-02 gravitational constants Float32\nj4c_jgm03 JGM-03 gravitational constants Float64\nj4c_jgm03_f32 JGM-03 gravitational constants Float32","category":"page"},{"location":"man/propagators/j4/","page":"J4","title":"J4","text":"note: Note\nThe type used in the propagation will be the same as used to define the constants in the structure j4c.","category":"page"},{"location":"man/propagators/j4/","page":"J4","title":"J4","text":"orb = KeplerianElements(\n           date_to_jd(2023, 1, 1, 0, 0, 0),\n           7190.982e3,\n           0.001111,\n           98.405 |> deg2rad,\n           100    |> deg2rad,\n           90     |> deg2rad,\n           19     |> deg2rad\n       )\n\norbp = Propagators.init(Val(:J4), orb; j4c = j4c_jgm03)","category":"page"},{"location":"man/propagators/j4/#Fitting-Mean-Elements","page":"J4","title":"Fitting Mean Elements","text":"","category":"section"},{"location":"man/propagators/j4/","page":"J4","title":"J4","text":"We can use the function:","category":"page"},{"location":"man/propagators/j4/","page":"J4","title":"J4","text":"Propagators.fit_mean_elements(::Val{:J4}, vjd::AbstractVector{Tjd}, vr_i::AbstractVector{Tv}, vv_i::AbstractVector{Tv}; kwargs...) -> KeplerianElements{Float64, Float64}, SMatrix{6, 6, Float64}","category":"page"},{"location":"man/propagators/j4/","page":"J4","title":"J4","text":"to fit a set of mean Keplerian elements for the J4 orbit propagator using the osculating elements represented by a set of position vectors vr_i [m] and a set of velocity vectors vv_i [m / s] represented in an inertial reference frame at instants in the array vjd [Julian Day].","category":"page"},{"location":"man/propagators/j4/","page":"J4","title":"J4","text":"It returns the fitted Keplerian elements and the final covariance matrix of the least-square algorithm.","category":"page"},{"location":"man/propagators/j4/","page":"J4","title":"J4","text":"note: Note\nThis algorithm version will allocate a new J4 propagator with the default constants j4c_egm2008. If another set of constants are required, use the function Propagators.fit_mean_elements! instead.","category":"page"},{"location":"man/propagators/j4/","page":"J4","title":"J4","text":"The following keywords are available to configure the fitting process:","category":"page"},{"location":"man/propagators/j4/","page":"J4","title":"J4","text":"atol::Number: Tolerance for the residue absolute value. If the residue is lower than   atol at any iteration, the computation loop stops.   (Default = 2e-4)\nrtol::Number: Tolerance for the relative difference between the residues. If the   relative difference between the residues in two consecutive iterations is lower than   rtol, the computation loop stops.   (Default = 2e-4)\ninitial_guess::Union{Nothing, KeplerianElements}: Initial guess for the mean elements   fitting process. If it is nothing, the algorithm will obtain an initial estimate from   the osculating elements in vr_i and vv_i.   (Default = nothing)\njacobian_perturbation::Number: Initial state perturbation to compute the   finite-difference when calculating the Jacobian matrix.   (Default = 1e-3)\njacobian_perturbation_tol::Number: Tolerance to accept the perturbation when calculating   the Jacobian matrix. If the computed perturbation is lower than   jacobian_perturbation_tol, we increase it until it absolute value is higher than   jacobian_perturbation_tol.   (Default = 1e-7)\nmax_iterations::Int: Maximum number of iterations allowed for the least-square fitting.   (Default = 50)\nmean_elements_epoch::Number: Epoch for the fitted mean elements.   (Default = vjd[end])\nverbose::Bool: If true, the algorithm prints debugging information to stdout.   (Default = true)\nweight_vector::AbstractVector: Vector with the measurements weights for the least-square   algorithm. We assemble the weight matrix W as a diagonal matrix with the elements in   weight_vector at its diagonal.   (Default = @SVector(ones(Bool, 6)))","category":"page"},{"location":"man/propagators/j4/","page":"J4","title":"J4","text":"vr_i = [\n    [-6792.402703741442, 2192.6458461287293, 0.18851758695295118]  .* 1000,\n    [-1781.214419290065, 1619.7795321872854, 6707.771633846665]    .* 1000,\n    [ 5693.643675547716, -1192.342828671633, 4123.976025977494]    .* 1000,\n    [ 5291.613719530499, -2354.5417593130833, -4175.561367156414]  .* 1000,\n    [-2416.3705905186903, -268.74923235392623, -6715.411357310478] .* 1000,\n    [-6795.043410709359, 2184.4414321930635, -0.4327055325971031]  .* 1000,\n];\n\nvv_i = [\n    [0.3445760107690598, 1.0395135806993514, 7.393686131436984]    .* 1000,\n    [6.875680282038698, -1.864319399615942, 2.270603214569518]     .* 1000,\n    [3.8964090757666496, -2.1887896252945875, -5.9960180359219075] .* 1000,\n    [-4.470258022565413, 0.5119576359985208, -5.9608372367141635]  .* 1000,\n    [-6.647358060413909, 2.495415251255861, 2.292118747543002]     .* 1000,\n    [0.3427096905434428, 1.040125572862349, 7.3936887585116855]    .* 1000,\n];\n\nvjd = [\n    2.46002818657856e6\n    2.460028200467449e6\n    2.460028214356338e6\n    2.4600282282452267e6\n    2.4600282421341157e6\n    2.4600282560230047e6\n];\n\norb, P = Propagators.fit_mean_elements(Val(:J4), vjd, vr_i, vv_i)\n\norb","category":"page"},{"location":"man/propagators/j4/#References","page":"J4","title":"References","text":"","category":"section"},{"location":"man/propagators/j4/","page":"J4","title":"J4","text":"[1] Vallado, D. A (2013). Fundamentals of Astrodynamics and Applications. 4th ed. Microcosm Press, Hawthorn, CA, USA.\n[2] Kozai, Y (1959). The Motion of a Close Earth Satellite. The Astronomical Journal, v. 64, no. 1274, pp. 367 – 377.","category":"page"},{"location":"man/usage/#Usage","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"CurrentModule = SatelliteToolboxPropagators","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"using SatelliteToolboxPropagators","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"All the propagators can be accessed using the available API, which allows to initialize and propagate the orbit.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"All the API function are available inside the module Propagators that is exported by this package.","category":"page"},{"location":"man/usage/#Initialization","page":"Usage","title":"Initialization","text":"","category":"section"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"We can initialize an orbit propagator using the function:","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"Propagators.init(::Val{:propagator}, args...; kwargs...)","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"It initializes a propagator of type :propagator using the arguments args... and keywords kwargs... supported by it. Currently, the following algorithms are available:","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"Propagator Name Symbol\nJ2 analytical orbit propagator :J2\nJ2 osculating analytical orbit propagator :J2osc\nJ4 analytical orbit propagator :J4\nJ4 osculating analytical orbit propagator :J4osc\nSGP4/SDP4 orbit propagator :SGP4\nTwo body analytical orbit propagator :TwoBody","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"See the documentation of each algorithm to verify the supported arguments and keywords.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"For example, a J2 analytical orbit propagator can be initialized with a set of mean elements as follows:","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"orb = KeplerianElements(\n    date_to_jd(2023, 1, 1, 0, 0, 0),\n    7190.982e3,\n    0.001111,\n    98.405 |> deg2rad,\n    100    |> deg2rad,\n    90     |> deg2rad,\n    19     |> deg2rad\n)\n\norbp = Propagators.init(Val(:J2), orb)","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"We also have the function:","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"init!(orbp::OrbitPropagator, args...; kwargs...)","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"that initializes the propagator orbp in-place using the arguments args... and keywords kwargs.... This function allows to reduce the memory allocation when performing multiple initialization. However, notice that this function is optional in the propagator API. Hence, some algorithms might not support it.","category":"page"},{"location":"man/usage/#Propagate-the-Orbit","page":"Usage","title":"Propagate the Orbit","text":"","category":"section"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"After the initialization, we can propagate the orbit using some functions as follows.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"propagate!(orbp::OrbitPropagator{Tepoch, T}, t::Number) where {Tepoch, T}","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"This function propagates the orbit using orbp by t [s] from the initial orbit epoch. It returns two vectors: the position [m] and velocity [m/s]. Both are represented in the same inertial reference frame used to describe the input data during the propagator initialization.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"For example, using the initialized propagator, we can propagate the orbit by 6000s as follows:","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"Propagators.propagate!(orbp, 6000)","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"propagate_to_epoch!(orbp::OrbitPropagator{Tepoch, T}, jd::Number) where {Tepoch, T}","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"This function propagates the orbit using orbp until the epoch jd [Julian Day]. It returns two vectors: the position [m] and velocity [m/s]. Both are represented in the same inertial reference frame used to describe the input data during the propagator initialization.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"For example, using the initialized propagator, we can propagate the orbit to 2023-01-02T00:00:00 as follows:","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"Propagators.propagate_to_epoch!(orbp, date_to_jd(2023, 1, 2, 0, 0, 0))","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"step!(orbp::OrbitPropagator{Tepoch, T}, Δt::Number) where {Tepoch, T}","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"Every time we propagate the orbit, the propagation instant is recorded inside the structure. Hence, we can use the function step! to propagate the orbit by Δt [s] from the current orbit epoch. It returns two vectors: the position [m] and velocity [m/s]. Both are represented in the same inertial reference frame used to describe the input data during the propagator initialization.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"For example, using the initialized propagator, we can advance the propagation by 60 s as follows:","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"orbp\n\nPropagators.step!(orbp, 60)\n\norbp","category":"page"},{"location":"man/usage/#Simultaneous-Initialization-and-Propagation","page":"Usage","title":"Simultaneous Initialization and Propagation","text":"","category":"section"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"We can use the following functions to simultaneously initialize and propagate the orbit:","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"propagate(::Val{:propagator}, Δt::Number, args...; kwargs...)\npropagate_to_epoch(::Val{:propagator}, jd::Number, args...; kwargs...)","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"The symbol :propagator, the arguments args..., and the keywords kwargs... are the same as described in the section related to the propagator initialization.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"The first function propagates the orbit by Δt [s] from the initial epoch, whereas the second propagated the orbit until the instant jd [Julian Day].","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"Both functions returns the position vector [m], the velocity vector [m/s], and the initialized propagator structure. Notice that both vectors are represented in the same inertial reference frame used to describe the input data for the initialization.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"However, notice that those functions are optional in the propagator API. Hence, some propagators might not support them.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"For example, we can propagate by 60 s a set of mean elements using a J2 analytical propagator as follows:","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"Propagators.propagate(Val(:J2), 60, orb)","category":"page"},{"location":"man/usage/#Helpers","page":"Usage","title":"Helpers","text":"","category":"section"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"We have the following functions that provide some useful information related to the propagators.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"epoch(orbp::OrbitPropagator{Tepoch, T}) where {Tepoch<:Number, T<:Number}","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"It returns the initial elements' epoch of the propagator orbp [JD].","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"Propagators.epoch(orbp)","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"last_instant(orbp::OrbitPropagator{Tepoch, T}) where {Tepoch<:Number, T<:Number}","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"It returns the last propagation instant [s] measured from the input elements' epoch.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"Propagators.last_instant(orbp)","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"name(orbp::OrbitPropagator)","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"It returns the propagator name.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"Propagators.name(orbp)","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"mean_elements(orbp::OrbitPropagator)","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"It returns the mean elements using the structure KeplerianElements of the latest propagation performed by orbp. Notice that this is an optional funciton in the propagators' API. If a propagator does not support it, this function returns nothing.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"Propagators.mean_elements(orbp)","category":"page"},{"location":"man/propagators/sgp4/#SGP4/SDP4","page":"SGP4/SDP4","title":"SGP4/SDP4","text":"","category":"section"},{"location":"man/propagators/sgp4/","page":"SGP4/SDP4","title":"SGP4/SDP4","text":"CurrentModule = SatelliteToolboxPropagators","category":"page"},{"location":"man/propagators/sgp4/","page":"SGP4/SDP4","title":"SGP4/SDP4","text":"using SatelliteToolboxPropagators","category":"page"},{"location":"man/propagators/sgp4/","page":"SGP4/SDP4","title":"SGP4/SDP4","text":"This package implements the interface to the SGP4/SDP4 propagator provided by SatelliteToolboxSgp4.jl.","category":"page"},{"location":"man/propagators/sgp4/#Algorithm","page":"SGP4/SDP4","title":"Algorithm","text":"","category":"section"},{"location":"man/propagators/sgp4/","page":"SGP4/SDP4","title":"SGP4/SDP4","text":"The SGP4/SDP4 implementation was built using [1, 2, 3].","category":"page"},{"location":"man/propagators/sgp4/#Initialization","page":"SGP4/SDP4","title":"Initialization","text":"","category":"section"},{"location":"man/propagators/sgp4/","page":"SGP4/SDP4","title":"SGP4/SDP4","text":"We must initialize the SGP4/SDP4 propagator with a two-line element set (TLE) using the following function:","category":"page"},{"location":"man/propagators/sgp4/","page":"SGP4/SDP4","title":"SGP4/SDP4","text":"Propagators.init(Val(:SGP4), tle::TLE; kwargs...) -> OrbitPropagatorSgp4","category":"page"},{"location":"man/propagators/sgp4/","page":"SGP4/SDP4","title":"SGP4/SDP4","text":"which creates a SGP4/SDP4 propagator structure OrbitPropagatorSgp4 with the tle. The following keyword selects the gravitational constants for the propagation algorithm:","category":"page"},{"location":"man/propagators/sgp4/","page":"SGP4/SDP4","title":"SGP4/SDP4","text":"sgp4c::Sgp4Constants: SGP4 orbit propagator constants (see Sgp4Constants).   (Default = sgp4c_wgs84)","category":"page"},{"location":"man/propagators/sgp4/","page":"SGP4/SDP4","title":"SGP4/SDP4","text":"The package [SatelliteToolboxSgp4.jl] contains some pre-build constants for this propagator:","category":"page"},{"location":"man/propagators/sgp4/","page":"SGP4/SDP4","title":"SGP4/SDP4","text":"SGP4/SDP4 Propagator Constants Description Type\nsgp4c_wgs84 Constants based on WGS-84 Float64\nsgp4c_wgs84_f32 Constants based on WGS-84 Float32\nsgp4c_wgs72 Constants based on WGS-72 Float64\nsgp4c_wgs72_f32 Constants based on WGS-72 Float32","category":"page"},{"location":"man/propagators/sgp4/","page":"SGP4/SDP4","title":"SGP4/SDP4","text":"note: Note\nThe type used in the propagation will be the same as used to define the constants in the structure sgp4c.","category":"page"},{"location":"man/propagators/sgp4/","page":"SGP4/SDP4","title":"SGP4/SDP4","text":"note: Note\nThe package SatelliteToolboxTle.jl defines the type TLE, which is re-exported here. It contains some useful functionalities, such as TLE fetching from online services. For more information, refer to the package documentation.","category":"page"},{"location":"man/propagators/sgp4/","page":"SGP4/SDP4","title":"SGP4/SDP4","text":"tle = tle\"\"\"\n       AMAZONIA 1\n       1 47699U 21015A   23083.68657856 -.00000044  10000-8  43000-4 0  9990\n       2 47699  98.4304 162.1097 0001247 136.2017 223.9283 14.40814394108652\"\"\"\n\nPropagators.init(Val(:SGP4), tle)","category":"page"},{"location":"man/propagators/sgp4/","page":"SGP4/SDP4","title":"SGP4/SDP4","text":"We also support initializing an SGP4/SDP4 propagator passing the TLE information in individual terms:","category":"page"},{"location":"man/propagators/sgp4/","page":"SGP4/SDP4","title":"SGP4/SDP4","text":"Propagators.init(Val(:SGP4), epoch::Number, n₀::Number, e₀::Number, i₀::Number, Ω₀::Number, ω₀::Number, M₀::Number, bstar::Number; kwargs...) -> OrbitPropagatorSgp4","category":"page"},{"location":"man/propagators/sgp4/","page":"SGP4/SDP4","title":"SGP4/SDP4","text":"where:","category":"page"},{"location":"man/propagators/sgp4/","page":"SGP4/SDP4","title":"SGP4/SDP4","text":"epoch::Number: Epoch of the orbital elements [Julian Day].\nn₀::Number: SGP type \"mean\" mean motion at epoch [rad/s].\ne₀::Number: \"Mean\" eccentricity at epoch.\ni₀::Number: \"Mean\" inclination at epoch [rad].\nΩ₀::Number: \"Mean\" longitude of the ascending node at epoch [rad].\nω₀::Number: \"Mean\" argument of perigee at epoch [rad].\nM₀::Number: \"Mean\" mean anomaly at epoch [rad].\nbstar::Number: Drag parameter (B*).","category":"page"},{"location":"man/propagators/sgp4/","page":"SGP4/SDP4","title":"SGP4/SDP4","text":"The keywords kwargs... are the same as in the first version of this function.","category":"page"},{"location":"man/propagators/sgp4/#Fitting-TLEs","page":"SGP4/SDP4","title":"Fitting TLEs","text":"","category":"section"},{"location":"man/propagators/sgp4/","page":"SGP4/SDP4","title":"SGP4/SDP4","text":"We can use the function:","category":"page"},{"location":"man/propagators/sgp4/","page":"SGP4/SDP4","title":"SGP4/SDP4","text":"Propagators.fit_mean_elements(::Val{:SGP4}, vjd::AbstractVector{Tjd}, vr_teme::AbstractVector{Tv}, vv_teme::AbstractVector{Tv}; kwargs...) -> KeplerianElements{Float64, Float64}, SMatrix{6, 6, Float64}","category":"page"},{"location":"man/propagators/sgp4/","page":"SGP4/SDP4","title":"SGP4/SDP4","text":"to fit a Two-Line Element set (TLE) for the SGP4 orbit propagator using the osculating elements represented by a set of position vectors vr_teme [m] and a set of velocity vectors vv_teme [m / s] represented in the True-Equator, Mean-Equinox reference frame (TEME) at instants in the array vjd [Julian Day].","category":"page"},{"location":"man/propagators/sgp4/","page":"SGP4/SDP4","title":"SGP4/SDP4","text":"It returns the fitted TLE and the final covariance matrix of the least-square algorithm.","category":"page"},{"location":"man/propagators/sgp4/","page":"SGP4/SDP4","title":"SGP4/SDP4","text":"This algorithm was based on [4].","category":"page"},{"location":"man/propagators/sgp4/","page":"SGP4/SDP4","title":"SGP4/SDP4","text":"note: Note\nThis algorithm version will allocate a new SGP4 propagator with the default constants sgp4c_wgs84. If another set of constants are required, use the function Propagators.fit_mean_elements! instead.","category":"page"},{"location":"man/propagators/sgp4/","page":"SGP4/SDP4","title":"SGP4/SDP4","text":"The following keywords are available to configure the fitting process:","category":"page"},{"location":"man/propagators/sgp4/","page":"SGP4/SDP4","title":"SGP4/SDP4","text":"atol::Number: Tolerance for the residue absolute value. If the residue is lower than   atol at any iteration, the computation loop stops.   (Default = 2e-4)\nrtol::Number: Tolerance for the relative difference between the residues. If the   relative difference between the residues in two consecutive iterations is lower than   rtol, the computation loop stops.   (Default = 2e-4)\nestimate_bstar::Bool: If true, the algorithm will try to estimate the B* parameter.   Otherwise, it will be set to 0 or to the value in initial guess (see section  Initial   Guess).   (Default = true)\ninitial_guess::Union{Nothing, AbstractVector, TLE}: Initial guess for the TLE fitting   process. If it is nothing, the algorithm will obtain an initial estimate from the   osculating elements in vr_teme and vv_teme. For more information, see the section   Initial Guess.   (Default = nothing)\njacobian_perturbation::Number: Initial state perturbation to compute the   finite-difference when calculating the Jacobian matrix.   (Default = 1e-3)\njacobian_perturbation_tol::Number: Tolerance to accept the perturbation when calculating   the Jacobian matrix. If the computed perturbation is lower than   jacobian_perturbation_tol, we increase it until it absolute value is higher than   jacobian_perturbation_tol.   (Default = 1e-7)\nmax_iterations::Int: Maximum number of iterations allowed for the least-square fitting.   (Default = 50)\nmean_elements_epoch::Number: Epoch for the fitted TLE.   (Default = vjd[end])\nverbose::Bool: If true, the algorithm prints debugging information to stdout.   (Default = true)\nweight_vector::AbstractVector: Vector with the measurements weights for the least-square   algorithm. We assemble the weight matrix W as a diagonal matrix with the elements in   weight_vector at its diagonal.   (Default = @SVector(ones(Bool, 6)))\nclassification::Char: Satellite classification character for the output TLE.   (Default = 'U')\nelement_set_number::Int: Element set number for the output TLE.   (Default = 0)\ninternational_designator::String: International designator string for the output TLE.   (Default = \"999999\")\nname::String: Satellite name for the output TLE.   (Default = \"UNDEFINED\")\nrevolution_number::Int: Revolution number for the output TLE.   (Default = 0)\nsatellite_number::Int: Satellite number for the output TLE.   (Default = 9999)","category":"page"},{"location":"man/propagators/sgp4/","page":"SGP4/SDP4","title":"SGP4/SDP4","text":"vr_teme = [\n    [-6792.402703741442, 2192.6458461287293, 0.18851758695295118] .* 1000,\n    [-6357.88873265975, 2391.9476768911686, 2181.838771262736] .* 1000\n];\n\nvv_teme = [\n    [0.3445760107690598, 1.0395135806993514, 7.393686131436984] .* 1000,\n    [2.5285015912807003, 0.27812476784300005, 7.030323100703928] .* 1000\n];\n\nvjd = [\n    2.46002818657856e6,\n    2.460028190050782e6\n];\n\ntle, P = Propagators.fit_mean_elements(Val(:SGP4), vjd, vr_teme, vv_teme; estimate_bstar = false)\n\ntle","category":"page"},{"location":"man/propagators/sgp4/#References","page":"SGP4/SDP4","title":"References","text":"","category":"section"},{"location":"man/propagators/sgp4/","page":"SGP4/SDP4","title":"SGP4/SDP4","text":"[1] Hoots, F. R., Roehrich, R. L (1980). Models for Propagation of NORAD Elements Set. Spacetrack Report No. 3.\n[2] Vallado, D. A., Crawford, P., Hujsak, R., Kelso, T. S (2006). Revisiting Spacetrack Report #3: Rev1. AIAA.\n[3] SGP4 Source code of STRF, which the C code was converted by Paul. S. Crawford and Andrew R. Brooks.\n[4] Vallado, D. A., Crawford, P (2008). SGP4 Orbit Determination. AIAA.","category":"page"},{"location":"man/propagators/twobody/#Two-Body-Analytical-Propagator","page":"Two-Body","title":"Two Body Analytical Propagator","text":"","category":"section"},{"location":"man/propagators/twobody/","page":"Two-Body","title":"Two-Body","text":"CurrentModule = SatelliteToolboxPropagators","category":"page"},{"location":"man/propagators/twobody/","page":"Two-Body","title":"Two-Body","text":"using SatelliteToolboxPropagators","category":"page"},{"location":"man/propagators/twobody/","page":"Two-Body","title":"Two-Body","text":"The two-body analytical orbit propagator considers the Earth a perfect sphere with uniform density. Hence, it propagates the orbit using the solution considering Newtonian gravity. It has an extremely low precision but with a minimal computational burden. Thus, it is helpful in some analysis that requires propagating the orbit many times for short periods.","category":"page"},{"location":"man/propagators/twobody/#Algorithm","page":"Two-Body","title":"Algorithm","text":"","category":"section"},{"location":"man/propagators/twobody/","page":"Two-Body","title":"Two-Body","text":"The algorithm implemented here is based on [1].","category":"page"},{"location":"man/propagators/twobody/","page":"Two-Body","title":"Two-Body","text":"Since we are considering a spherical Earth with uniform density, gravity points towards the center of Earth. Thus, we propagate the orbit by updating the satellite mean anomaly since all other Keplerian elements do not change. The equation to correct the mean anomaly is:","category":"page"},{"location":"man/propagators/twobody/","page":"Two-Body","title":"Two-Body","text":"M(t) = M_0 + sqrtfracmua_0^3 cdot left(t - t_0right)","category":"page"},{"location":"man/propagators/twobody/","page":"Two-Body","title":"Two-Body","text":"where t_0 is the initial mean elements' epoch, a_0 is the mean semi-major axis, and mu the Earth's standard gravitational parameter.","category":"page"},{"location":"man/propagators/twobody/#Initialization","page":"Two-Body","title":"Initialization","text":"","category":"section"},{"location":"man/propagators/twobody/","page":"Two-Body","title":"Two-Body","text":"We can initialize the two-body analytical propagator with the following function:","category":"page"},{"location":"man/propagators/twobody/","page":"Two-Body","title":"Two-Body","text":"Propagators.init(Val(:TwoBody), orb₀::KeplerianElements; kwargs...) -> OrbitPropagatorTwoBody","category":"page"},{"location":"man/propagators/twobody/","page":"Two-Body","title":"Two-Body","text":"which creates a two-body propagator structure OrbitPropagatorTwoBody with the mean Keplerian elements orb₀. The following keyword selects the standard gravitational parameter for the propagation algorithm:","category":"page"},{"location":"man/propagators/twobody/","page":"Two-Body","title":"Two-Body","text":"m0::T: Standard gravitational parameter of the central body [m³/s²].   (Default = tbc_m0)","category":"page"},{"location":"man/propagators/twobody/","page":"Two-Body","title":"Two-Body","text":"This package contains some pre-built gravitational parameters of the Earth for this propagator:","category":"page"},{"location":"man/propagators/twobody/","page":"Two-Body","title":"Two-Body","text":"Two-Body Propagator Constant Description Type\ntbc_m0 Earth's standard gravitational parameter Float64\ntbc_m0_f32 Earth's standard gravitational parameter Float32","category":"page"},{"location":"man/propagators/twobody/","page":"Two-Body","title":"Two-Body","text":"note: Note\nThe type used in the propagation will be the same as used to define the gravitational constant μ.","category":"page"},{"location":"man/propagators/twobody/","page":"Two-Body","title":"Two-Body","text":"orb = KeplerianElements(\n           date_to_jd(2023, 1, 1, 0, 0, 0),\n           7190.982e3,\n           0.001111,\n           98.405 |> deg2rad,\n           100    |> deg2rad,\n           90     |> deg2rad,\n           19     |> deg2rad\n       )\n\norbp = Propagators.init(Val(:TwoBody), orb)","category":"page"},{"location":"man/propagators/twobody/#References","page":"Two-Body","title":"References","text":"","category":"section"},{"location":"man/propagators/twobody/","page":"Two-Body","title":"Two-Body","text":"[1] Vallado, D. A (2013). Fundamentals of Astrodynamics and Applications. 4th ed. Microcosm Press, Hawthorn, CA, USA.","category":"page"},{"location":"lib/library/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"lib/library/","page":"Library","title":"Library","text":"Documentation for SatelliteToolboxPropagators.jl.","category":"page"},{"location":"lib/library/","page":"Library","title":"Library","text":"Modules = [SatelliteToolboxPropagators, Propagators]","category":"page"},{"location":"lib/library/#SatelliteToolboxPropagators.J2OsculatingPropagator","page":"Library","title":"SatelliteToolboxPropagators.J2OsculatingPropagator","text":"mutable struct J2OsculatingPropagator{Tepoch<:Number, T<:Number}\n\nJ2 osculating orbit propagator structure.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolboxPropagators.J2Propagator","page":"Library","title":"SatelliteToolboxPropagators.J2Propagator","text":"mutable struct J2Propagator{Tepoch<:Number, T<:Number}\n\nJ2 orbit propagator structure.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolboxPropagators.J2PropagatorConstants","page":"Library","title":"SatelliteToolboxPropagators.J2PropagatorConstants","text":"struct J2PropagatorConstants{T<:Number}\n\nConstants for the J2 orbit propagator.\n\nFields\n\nR0::T: Earth equatorial radius [m].\nμm::T: √(GM / R0^3) [er/s]^(3/2).\nJ2::T: The second gravitational zonal harmonic of the Earth.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolboxPropagators.J4OsculatingPropagator","page":"Library","title":"SatelliteToolboxPropagators.J4OsculatingPropagator","text":"mutable struct J4OsculatingPropagator{Tepoch<:Number, T<:Number}\n\nJ4 osculating orbit propagator structure.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolboxPropagators.J4Propagator","page":"Library","title":"SatelliteToolboxPropagators.J4Propagator","text":"J4Propagator{Tepoch, T}\n\nJ4 orbit propagator structure.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolboxPropagators.J4PropagatorConstants","page":"Library","title":"SatelliteToolboxPropagators.J4PropagatorConstants","text":"struct J4PropagatorConstants{T<:Number}\n\nConstants for the J4 orbit propagator.\n\nFields\n\nR0::T: Earth equatorial radius [m].\nμm::T: √(GM / R0^3) [er/s]^(3/2).\nJ2::T: The second gravitational zonal harmonic of the Earth.\nJ4::T: The fourth gravitational zonal harmonic of the Earth.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolboxPropagators.OrbitPropagatorJ2","page":"Library","title":"SatelliteToolboxPropagators.OrbitPropagatorJ2","text":"OrbitPropagatorJ2{Tepoch, T} <: OrbitPropagator{Tepoch, T}\n\nJ2 orbit propagator.\n\nFields\n\nj2d: Structure that stores the J2 orbit propagator data (see J2Propagator).\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolboxPropagators.OrbitPropagatorJ2Osculating","page":"Library","title":"SatelliteToolboxPropagators.OrbitPropagatorJ2Osculating","text":"OrbitPropagatorJ2Osculating{Tepoch, T} <: OrbitPropagator{Tepoch, T}\n\nJ2 osculating orbit propagator.\n\nFields\n\nj2oscd: Structure that stores the J2 osculating orbit propagator data (see   J2OsculatingPropagator).\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolboxPropagators.OrbitPropagatorJ4","page":"Library","title":"SatelliteToolboxPropagators.OrbitPropagatorJ4","text":"OrbitPropagatorJ4{Tepoch, T} <: OrbitPropagator{Tepoch, T}\n\nJ4 orbit propagator.\n\nFields\n\nj4d: Structure that stores the J4 orbit propagator data (see J4Propagator).\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolboxPropagators.OrbitPropagatorJ4Osculating","page":"Library","title":"SatelliteToolboxPropagators.OrbitPropagatorJ4Osculating","text":"OrbitPropagatorJ4Osculating{Tepoch, T} <: OrbitPropagator{Tepoch, T}\n\nJ4 osculating orbit propagator.\n\nFields\n\nj4oscd: Structure that stores the J4 osculating orbit propagator data (see   J4OsculatingPropagator).\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolboxPropagators.OrbitPropagatorSgp4","page":"Library","title":"SatelliteToolboxPropagators.OrbitPropagatorSgp4","text":"OrbitPropagatorSgp4{Tepoch, T} <: OrbitPropagator{Tepoch, T}\n\nSGP4 orbit propagator.\n\nFields\n\nsgp4d: Structure that stores the SGP4 orbit propagator data.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolboxPropagators.OrbitPropagatorTwoBody","page":"Library","title":"SatelliteToolboxPropagators.OrbitPropagatorTwoBody","text":"OrbitPropagatorTwoBody{Tepoch, T} <: OrbitPropagator{Tepoch, T}\n\nTwo body orbit propagator.\n\nFields\n\ntbd: Structure that stores the two body orbit propagator data (see   TwoBodyPropagator).\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolboxPropagators.TwoBodyPropagator","page":"Library","title":"SatelliteToolboxPropagators.TwoBodyPropagator","text":"mutable struct TwoBodyPropagator{Tepoch<:Number, T<:Number}\n\nTwo body orbit propagator structure.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolboxPropagators.Propagators.fit_mean_elements!-Union{Tuple{Tv}, Tuple{Tjd}, Tuple{OrbitPropagatorJ2, AbstractVector{Tjd}, AbstractVector{Tv}, AbstractVector{Tv}}} where {Tjd<:Number, Tv<:(AbstractVector)}","page":"Library","title":"SatelliteToolboxPropagators.Propagators.fit_mean_elements!","text":"Propagators.fit_mean_elements!(orbp::OrbitPropagatorJ2, vjd::AbstractVector{Tjd}, vr_i::AbstractVector{Tv}, vv_i::AbstractVector{Tv}; kwargs...) where {Tjd<:Number, Tv<:AbstractVector}\n\nFit a set of mean Keplerian elements for the J2 orbit propagator orbp using the osculating elements represented by a set of position vectors vr_i [m] and a set of velocity vectors vv_i [m / s] represented in an inertial reference frame at instants in the array vjd [Julian Day].\n\nnote: Note\nThe orbit propagator orbp will be initialized with the Keplerian elements returned by the function.\n\nKeywords\n\natol::Number: Tolerance for the residue absolute value. If the residue is lower than   atol at any iteration, the computation loop stops.   (Default = 2e-4)\nrtol::Number: Tolerance for the relative difference between the residues. If the   relative difference between the residues in two consecutive iterations is lower than   rtol, the computation loop stops.   (Default = 2e-4)\ninitial_guess::Union{Nothing, KeplerianElements}: Initial guess for the mean elements   fitting process. If it is nothing, the algorithm will obtain an initial estimate from   the osculating elements in vr_i and vv_i.   (Default = nothing)\njacobian_perturbation::Number: Initial state perturbation to compute the   finite-difference when calculating the Jacobian matrix.   (Default = 1e-3)\njacobian_perturbation_tol::Number: Tolerance to accept the perturbation when calculating   the Jacobian matrix. If the computed perturbation is lower than   jacobian_perturbation_tol, we increase it until it absolute value is higher than   jacobian_perturbation_tol.   (Default = 1e-7)\nmax_iterations::Int: Maximum number of iterations allowed for the least-square fitting.   (Default = 50)\nmean_elements_epoch::Number: Epoch for the fitted mean elements.   (Default = vjd[end])\nverbose::Bool: If true, the algorithm prints debugging information to stdout.   (Default = true)\nweight_vector::AbstractVector: Vector with the measurements weights for the least-square   algorithm. We assemble the weight matrix W as a diagonal matrix with the elements in   weight_vector at its diagonal.   (Default = @SVector(ones(Bool, 6)))\n\nReturns\n\nKeplerianElements{Float64, Float64}: Fitted Keplerian elements.\nSMatrix{6, 6, Float64}: Final covariance matrix of the least-square algorithm.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.Propagators.fit_mean_elements!-Union{Tuple{Tv}, Tuple{Tjd}, Tuple{OrbitPropagatorJ2Osculating, AbstractVector{Tjd}, AbstractVector{Tv}, AbstractVector{Tv}}} where {Tjd<:Number, Tv<:(AbstractVector)}","page":"Library","title":"SatelliteToolboxPropagators.Propagators.fit_mean_elements!","text":"Propagators.fit_mean_elements!(orbp::OrbitPropagatorJ2Osculating, vjd::AbstractVector{Tjd}, vr_i::AbstractVector{Tv}, vv_i::AbstractVector{Tv}; kwargs...) where {Tjd<:Number, Tv<:AbstractVector}\n\nFit a set of mean Keplerian elements for the J2 osculating orbit propagator orbp using the osculating elements represented by a set of position vectors vr_i [m] and a set of velocity vectors vv_i [m / s] represented in an inertial reference frame at instants in the array vjd [Julian Day].\n\nnote: Note\nThe orbit propagator orbp will be initialized with the Keplerian elements returned by the function.\n\nKeywords\n\natol::Number: Tolerance for the residue absolute value. If the residue is lower than   atol at any iteration, the computation loop stops.   (Default = 2e-4)\nrtol::Number: Tolerance for the relative difference between the residues. If the   relative difference between the residues in two consecutive iterations is lower than   rtol, the computation loop stops.   (Default = 2e-4)\ninitial_guess::Union{Nothing, KeplerianElements}: Initial guess for the mean elements   fitting process. If it is nothing, the algorithm will obtain an initial estimate from   the osculating elements in vr_i and vv_i.   (Default = nothing)\njacobian_perturbation::Number: Initial state perturbation to compute the   finite-difference when calculating the Jacobian matrix.   (Default = 1e-3)\njacobian_perturbation_tol::Number: Tolerance to accept the perturbation when calculating   the Jacobian matrix. If the computed perturbation is lower than   jacobian_perturbation_tol, we increase it until it absolute value is higher than   jacobian_perturbation_tol.   (Default = 1e-7)\nmax_iterations::Int: Maximum number of iterations allowed for the least-square fitting.   (Default = 50)\nmean_elements_epoch::Number: Epoch for the fitted mean elements.   (Default = vjd[end])\nverbose::Bool: If true, the algorithm prints debugging information to stdout.   (Default = true)\nweight_vector::AbstractVector: Vector with the measurements weights for the least-square   algorithm. We assemble the weight matrix W as a diagonal matrix with the elements in   weight_vector at its diagonal.   (Default = @SVector(ones(Bool, 6)))\n\nReturns\n\nKeplerianElements{Float64, Float64}: Fitted Keplerian elements.\nSMatrix{6, 6, Float64}: Final covariance matrix of the least-square algorithm.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.Propagators.fit_mean_elements!-Union{Tuple{Tv}, Tuple{Tjd}, Tuple{OrbitPropagatorJ4, AbstractVector{Tjd}, AbstractVector{Tv}, AbstractVector{Tv}}} where {Tjd<:Number, Tv<:(AbstractVector)}","page":"Library","title":"SatelliteToolboxPropagators.Propagators.fit_mean_elements!","text":"Propagators.fit_mean_elements!(orbp::OrbitPropagatorJ4, vjd::AbstractVector{Tjd}, vr_i::AbstractVector{Tv}, vv_i::AbstractVector{Tv}; kwargs...) where {Tjd<:Number, Tv<:AbstractVector}\n\nFit a set of mean Keplerian elements for the J4 orbit propagator orbp using the osculating elements represented by a set of position vectors vr_i [m] and a set of velocity vectors vv_i [m / s] represented in an inertial reference frame at instants in the array vjd [Julian Day].\n\nnote: Note\nThe orbit propagator orbp will be initialized with the Keplerian elements returned by the function.\n\nKeywords\n\natol::Number: Tolerance for the residue absolute value. If the residue is lower than   atol at any iteration, the computation loop stops.   (Default = 2e-4)\nrtol::Number: Tolerance for the relative difference between the residues. If the   relative difference between the residues in two consecutive iterations is lower than   rtol, the computation loop stops.   (Default = 2e-4)\ninitial_guess::Union{Nothing, KeplerianElements}: Initial guess for the mean elements   fitting process. If it is nothing, the algorithm will obtain an initial estimate from   the osculating elements in vr_i and vv_i.   (Default = nothing)\njacobian_perturbation::Number: Initial state perturbation to compute the   finite-difference when calculating the Jacobian matrix.   (Default = 1e-3)\njacobian_perturbation_tol::Number: Tolerance to accept the perturbation when calculating   the Jacobian matrix. If the computed perturbation is lower than   jacobian_perturbation_tol, we increase it until it absolute value is higher than   jacobian_perturbation_tol.   (Default = 1e-7)\nmax_iterations::Int: Maximum number of iterations allowed for the least-square fitting.   (Default = 50)\nmean_elements_epoch::Number: Epoch for the fitted mean elements.   (Default = vjd[end])\nverbose::Bool: If true, the algorithm prints debugging information to stdout.   (Default = true)\nweight_vector::AbstractVector: Vector with the measurements weights for the least-square   algorithm. We assemble the weight matrix W as a diagonal matrix with the elements in   weight_vector at its diagonal.   (Default = @SVector(ones(Bool, 6)))\n\nReturns\n\nKeplerianElements{Float64, Float64}: Fitted Keplerian elements.\nSMatrix{6, 6, Float64}: Final covariance matrix of the least-square algorithm.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.Propagators.fit_mean_elements!-Union{Tuple{Tv}, Tuple{Tjd}, Tuple{OrbitPropagatorJ4Osculating, AbstractVector{Tjd}, AbstractVector{Tv}, AbstractVector{Tv}}} where {Tjd<:Number, Tv<:(AbstractVector)}","page":"Library","title":"SatelliteToolboxPropagators.Propagators.fit_mean_elements!","text":"Propagators.fit_mean_elements!(orbp::OrbitPropagatorJ4Osculating, vjd::AbstractVector{Tjd}, vr_i::AbstractVector{Tv}, vv_i::AbstractVector{Tv}; kwargs...) where {Tjd<:Number, Tv<:AbstractVector}\n\nFit a set of mean Keplerian elements for the J4 osculating orbit propagator orbp using the osculating elements represented by a set of position vectors vr_i [m] and a set of velocity vectors vv_i [m / s] represented in an inertial reference frame at instants in the array vjd [Julian Day].\n\nnote: Note\nThe orbit propagator orbp will be initialized with the Keplerian elements returned by the function.\n\nKeywords\n\natol::Number: Tolerance for the residue absolute value. If the residue is lower than   atol at any iteration, the computation loop stops.   (Default = 2e-4)\nrtol::Number: Tolerance for the relative difference between the residues. If the   relative difference between the residues in two consecutive iterations is lower than   rtol, the computation loop stops.   (Default = 2e-4)\ninitial_guess::Union{Nothing, KeplerianElements}: Initial guess for the mean elements   fitting process. If it is nothing, the algorithm will obtain an initial estimate from   the osculating elements in vr_i and vv_i.   (Default = nothing)\njacobian_perturbation::Number: Initial state perturbation to compute the   finite-difference when calculating the Jacobian matrix.   (Default = 1e-3)\njacobian_perturbation_tol::Number: Tolerance to accept the perturbation when calculating   the Jacobian matrix. If the computed perturbation is lower than   jacobian_perturbation_tol, we increase it until it absolute value is higher than   jacobian_perturbation_tol.   (Default = 1e-7)\nmax_iterations::Int: Maximum number of iterations allowed for the least-square fitting.   (Default = 50)\nmean_elements_epoch::Number: Epoch for the fitted mean elements.   (Default = vjd[end])\nverbose::Bool: If true, the algorithm prints debugging information to stdout.   (Default = true)\nweight_vector::AbstractVector: Vector with the measurements weights for the least-square   algorithm. We assemble the weight matrix W as a diagonal matrix with the elements in   weight_vector at its diagonal.   (Default = @SVector(ones(Bool, 6)))\n\nReturns\n\nKeplerianElements{Float64, Float64}: Fitted Keplerian elements.\nSMatrix{6, 6, Float64}: Final covariance matrix of the least-square algorithm.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.Propagators.fit_mean_elements!-Union{Tuple{Tv}, Tuple{Tjd}, Tuple{OrbitPropagatorSgp4, AbstractVector{Tjd}, AbstractVector{Tv}, AbstractVector{Tv}}} where {Tjd<:Number, Tv<:(AbstractVector)}","page":"Library","title":"SatelliteToolboxPropagators.Propagators.fit_mean_elements!","text":"Propagators.fit_mean_elements!(orbp::OrbitPropagatorSgp4, vjd::AbstractVector{Tjd}, vr_teme::AbstractVector{Tv}, vv_teme::AbstractVector{Tv}; kwargs...) where {Tjd<:Number, Tv<:AbstractVector}\n\nFit a Two-Line Element set (TLE) for the SGP4 orbit propagator orbp using the osculating elements represented by a set of position vectors vr_teme [m] and a set of velocity vectors vv_teme [m / s] represented in the True-Equator, Mean-Equinox reference frame (TEME) at instants in the array vjd [Julian Day].\n\nThis algorithm was based on [1].\n\nnote: Note\nThe SGP4 orbit propagator orbp will be initialized with the TLE returned by the function.\n\nKeywords\n\natol::Number: Tolerance for the residue absolute value. If the residue is lower than   atol at any iteration, the computation loop stops.   (Default = 2e-4)\nrtol::Number: Tolerance for the relative difference between the residues. If the   relative difference between the residues in two consecutive iterations is lower than   rtol, the computation loop stops.   (Default = 2e-4)\nestimate_bstar::Bool: If true, the algorithm will try to estimate the B* parameter.   Otherwise, it will be set to 0 or to the value in initial guess (see section  Initial   Guess).   (Default = true)\ninitial_guess::Union{Nothing, AbstractVector, TLE}: Initial guess for the TLE fitting   process. If it is nothing, the algorithm will obtain an initial estimate from the   osculating elements in vr_teme and vv_teme. For more information, see the section   Initial Guess.   (Default = nothing)\njacobian_perturbation::Number: Initial state perturbation to compute the   finite-difference when calculating the Jacobian matrix.   (Default = 1e-3)\njacobian_perturbation_tol::Number: Tolerance to accept the perturbation when calculating   the Jacobian matrix. If the computed perturbation is lower than   jacobian_perturbation_tol, we increase it until it absolute value is higher than   jacobian_perturbation_tol.   (Default = 1e-7)\nmax_iterations::Int: Maximum number of iterations allowed for the least-square fitting.   (Default = 50)\nmean_elements_epoch::Number: Epoch for the fitted TLE.   (Default = vjd[end])\nverbose::Bool: If true, the algorithm prints debugging information to stdout.   (Default = true)\nweight_vector::AbstractVector: Vector with the measurements weights for the least-square   algorithm. We assemble the weight matrix W as a diagonal matrix with the elements in   weight_vector at its diagonal.   (Default = @SVector(ones(Bool, 6)))\nclassification::Char: Satellite classification character for the output TLE.   (Default = 'U')\nelement_set_number::Int: Element set number for the output TLE.   (Default = 0)\ninternational_designator::String: International designator string for the output TLE.   (Default = \"999999\")\nname::String: Satellite name for the output TLE.   (Default = \"UNDEFINED\")\nrevolution_number::Int: Revolution number for the output TLE.   (Default = 0)\nsatellite_number::Int: Satellite number for the output TLE.   (Default = 9999)\n\nReturns\n\nTLE: The fitted TLE.\nSMatrix{7, 7, T}: Final covariance matrix of the least-square algorithm.\n\nInitial Guess\n\nThis algorithm uses a least-square algorithm to fit a TLE based on a set of osculating state vectors. Since the system is chaotic, a good initial guess is paramount for algorithm convergence. We can provide an initial guess using the keyword initial_guess.\n\nIf initial_guess is a TLE, we update the TLE epoch using the function update_sgp4_tle_epoch! to the desired one in mean_elements_epoch. Afterward, we use this new TLE as the initial guess.\n\nIf initial_guess is an AbstractVector, we use this vector as the initial mean state vector for the algorithm. It must contain 7 elements as follows:\n\n┌                                    ┐\n│ IDs 1 to 3: Mean position [km]     │\n│ IDs 4 to 6: Mean velocity [km / s] │\n│ ID  7:      Bstar         [1 / er] │\n└                                    ┘\n\nIf initial_guess is nothing, the algorithm takes the closest osculating state vector to the mean_elements_epoch and uses it as the initial mean state vector. In this case, the epoch is set to the same epoch of the osculating data in vjd. When the fitted TLE is obtained, the algorithm uses the function update_sgp4_tle_epoch! to change its epoch to mean_elements_epoch.\n\nnote: Note\nIf initial_guess is not nothing, the B* initial estimate is obtained from the TLE or the state vector. Hence, if estimate_bstar is false, it will be kept constant with this initial value.\n\nReferences\n\n[1] Vallado, D. A., Crawford, P (2008). SGP4 Orbit Determination. American Institute   of Aeronautics ans Astronautics.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.Propagators.fit_mean_elements-Union{Tuple{Tv}, Tuple{Tjd}, Tuple{Val{:J2osc}, AbstractVector{Tjd}, AbstractVector{Tv}, AbstractVector{Tv}}} where {Tjd<:Number, Tv<:(AbstractVector)}","page":"Library","title":"SatelliteToolboxPropagators.Propagators.fit_mean_elements","text":"Propagators.fit_mean_elements(::Val{:J2osc}, vjd::AbstractVector{Tjd}, vr_i::AbstractVector{Tv}, vv_i::AbstractVector{Tv}; kwargs...) -> KeplerianElements{Float64, Float64}, SMatrix{6, 6, Float64}\n\nFit a set of mean Keplerian elements for the J2 osculating orbit propagator using the osculating elements represented by a set of position vectors vr_i [m] and a set of velocity vectors vv_i [m / s] represented in an inertial reference frame at instants in the array vjd [Julian Day].\n\nnote: Note\nThis algorithm version will allocate a new J2 osculating propagator with the default constants j2c_egm2008. If another set of constants are required, use the function Propagators.fit_mean_elements! instead.\n\nKeywords\n\natol::Number: Tolerance for the residue absolute value. If the residue is lower than   atol at any iteration, the computation loop stops.   (Default = 2e-4)\nrtol::Number: Tolerance for the relative difference between the residues. If the   relative difference between the residues in two consecutive iterations is lower than   rtol, the computation loop stops.   (Default = 2e-4)\ninitial_guess::Union{Nothing, KeplerianElements}: Initial guess for the mean elements   fitting process. If it is nothing, the algorithm will obtain an initial estimate from   the osculating elements in vr_i and vv_i.   (Default = nothing)\njacobian_perturbation::Number: Initial state perturbation to compute the   finite-difference when calculating the Jacobian matrix.   (Default = 1e-3)\njacobian_perturbation_tol::Number: Tolerance to accept the perturbation when calculating   the Jacobian matrix. If the computed perturbation is lower than   jacobian_perturbation_tol, we increase it until it absolute value is higher than   jacobian_perturbation_tol.   (Default = 1e-7)\nmax_iterations::Int: Maximum number of iterations allowed for the least-square fitting.   (Default = 50)\nmean_elements_epoch::Number: Epoch for the fitted mean elements.   (Default = vjd[end])\nverbose::Bool: If true, the algorithm prints debugging information to stdout.   (Default = true)\nweight_vector::AbstractVector: Vector with the measurements weights for the least-square   algorithm. We assemble the weight matrix W as a diagonal matrix with the elements in   weight_vector at its diagonal.   (Default = @SVector(ones(Bool, 6)))\n\nReturns\n\nKeplerianElements{Float64, Float64}: Fitted Keplerian elements.\nSMatrix{6, 6, Float64}: Final covariance matrix of the least-square algorithm.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.Propagators.fit_mean_elements-Union{Tuple{Tv}, Tuple{Tjd}, Tuple{Val{:J2}, AbstractVector{Tjd}, AbstractVector{Tv}, AbstractVector{Tv}}} where {Tjd<:Number, Tv<:(AbstractVector)}","page":"Library","title":"SatelliteToolboxPropagators.Propagators.fit_mean_elements","text":"Propagators.fit_mean_elements(::Val{:J2}, vjd::AbstractVector{Tjd}, vr_i::AbstractVector{Tv}, vv_i::AbstractVector{Tv}; kwargs...) -> KeplerianElements{Float64, Float64}, SMatrix{6, 6, Float64}\n\nFit a set of mean Keplerian elements for the J2 orbit propagator using the osculating elements represented by a set of position vectors vr_i [m] and a set of velocity vectors vv_i [m / s] represented in an inertial reference frame at instants in the array vjd [Julian Day].\n\nnote: Note\nThis algorithm version will allocate a new J2 propagator with the default constants j2c_egm2008. If another set of constants are required, use the function Propagators.fit_mean_elements! instead.\n\nKeywords\n\natol::Number: Tolerance for the residue absolute value. If the residue is lower than   atol at any iteration, the computation loop stops.   (Default = 2e-4)\nrtol::Number: Tolerance for the relative difference between the residues. If the   relative difference between the residues in two consecutive iterations is lower than   rtol, the computation loop stops.   (Default = 2e-4)\ninitial_guess::Union{Nothing, KeplerianElements}: Initial guess for the mean elements   fitting process. If it is nothing, the algorithm will obtain an initial estimate from   the osculating elements in vr_i and vv_i.   (Default = nothing)\njacobian_perturbation::Number: Initial state perturbation to compute the   finite-difference when calculating the Jacobian matrix.   (Default = 1e-3)\njacobian_perturbation_tol::Number: Tolerance to accept the perturbation when calculating   the Jacobian matrix. If the computed perturbation is lower than   jacobian_perturbation_tol, we increase it until it absolute value is higher than   jacobian_perturbation_tol.   (Default = 1e-7)\nmax_iterations::Int: Maximum number of iterations allowed for the least-square fitting.   (Default = 50)\nmean_elements_epoch::Number: Epoch for the fitted mean elements.   (Default = vjd[end])\nverbose::Bool: If true, the algorithm prints debugging information to stdout.   (Default = true)\nweight_vector::AbstractVector: Vector with the measurements weights for the least-square   algorithm. We assemble the weight matrix W as a diagonal matrix with the elements in   weight_vector at its diagonal.   (Default = @SVector(ones(Bool, 6)))\n\nReturns\n\nKeplerianElements{Float64, Float64}: Fitted Keplerian elements.\nSMatrix{6, 6, Float64}: Final covariance matrix of the least-square algorithm.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.Propagators.fit_mean_elements-Union{Tuple{Tv}, Tuple{Tjd}, Tuple{Val{:J4osc}, AbstractVector{Tjd}, AbstractVector{Tv}, AbstractVector{Tv}}} where {Tjd<:Number, Tv<:(AbstractVector)}","page":"Library","title":"SatelliteToolboxPropagators.Propagators.fit_mean_elements","text":"Propagators.fit_mean_elements(::Val{:J4osc}, vjd::AbstractVector{Tjd}, vr_i::AbstractVector{Tv}, vv_i::AbstractVector{Tv}; kwargs...) -> KeplerianElements{Float64, Float64}, SMatrix{6, 6, Float64}\n\nFit a set of mean Keplerian elements for the J4 osculating orbit propagator using the osculating elements represented by a set of position vectors vr_i [m] and a set of velocity vectors vv_i [m / s] represented in an inertial reference frame at instants in the array vjd [Julian Day].\n\nnote: Note\nThis algorithm version will allocate a new J4 osculating propagator with the default constants j4c_egm2008. If another set of constants are required, use the function Propagators.fit_mean_elements! instead.\n\nKeywords\n\natol::Number: Tolerance for the residue absolute value. If the residue is lower than   atol at any iteration, the computation loop stops.   (Default = 2e-4)\nrtol::Number: Tolerance for the relative difference between the residues. If the   relative difference between the residues in two consecutive iterations is lower than   rtol, the computation loop stops.   (Default = 2e-4)\ninitial_guess::Union{Nothing, KeplerianElements}: Initial guess for the mean elements   fitting process. If it is nothing, the algorithm will obtain an initial estimate from   the osculating elements in vr_i and vv_i.   (Default = nothing)\njacobian_perturbation::Number: Initial state perturbation to compute the   finite-difference when calculating the Jacobian matrix.   (Default = 1e-3)\njacobian_perturbation_tol::Number: Tolerance to accept the perturbation when calculating   the Jacobian matrix. If the computed perturbation is lower than   jacobian_perturbation_tol, we increase it until it absolute value is higher than   jacobian_perturbation_tol.   (Default = 1e-7)\nmax_iterations::Int: Maximum number of iterations allowed for the least-square fitting.   (Default = 50)\nmean_elements_epoch::Number: Epoch for the fitted mean elements.   (Default = vjd[end])\nverbose::Bool: If true, the algorithm prints debugging information to stdout.   (Default = true)\nweight_vector::AbstractVector: Vector with the measurements weights for the least-square   algorithm. We assemble the weight matrix W as a diagonal matrix with the elements in   weight_vector at its diagonal.   (Default = @SVector(ones(Bool, 6)))\n\nReturns\n\nKeplerianElements{Float64, Float64}: Fitted Keplerian elements.\nSMatrix{6, 6, Float64}: Final covariance matrix of the least-square algorithm.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.Propagators.fit_mean_elements-Union{Tuple{Tv}, Tuple{Tjd}, Tuple{Val{:J4}, AbstractVector{Tjd}, AbstractVector{Tv}, AbstractVector{Tv}}} where {Tjd<:Number, Tv<:(AbstractVector)}","page":"Library","title":"SatelliteToolboxPropagators.Propagators.fit_mean_elements","text":"Propagators.fit_mean_elements(::Val{:J4}, vjd::AbstractVector{Tjd}, vr_i::AbstractVector{Tv}, vv_i::AbstractVector{Tv}; kwargs...) -> KeplerianElements{Float64, Float64}, SMatrix{6, 6, Float64}\n\nFit a set of mean Keplerian elements for the J4 orbit propagator using the osculating elements represented by a set of position vectors vr_i [m] and a set of velocity vectors vv_i [m / s] represented in an inertial reference frame at instants in the array vjd [Julian Day].\n\nnote: Note\nThis algorithm version will allocate a new J4 propagator with the default constants j4c_egm2008. If another set of constants are required, use the function Propagators.fit_mean_elements! instead.\n\nKeywords\n\natol::Number: Tolerance for the residue absolute value. If the residue is lower than   atol at any iteration, the computation loop stops.   (Default = 2e-4)\nrtol::Number: Tolerance for the relative difference between the residues. If the   relative difference between the residues in two consecutive iterations is lower than   rtol, the computation loop stops.   (Default = 2e-4)\ninitial_guess::Union{Nothing, KeplerianElements}: Initial guess for the mean elements   fitting process. If it is nothing, the algorithm will obtain an initial estimate from   the osculating elements in vr_i and vv_i.   (Default = nothing)\njacobian_perturbation::Number: Initial state perturbation to compute the   finite-difference when calculating the Jacobian matrix.   (Default = 1e-3)\njacobian_perturbation_tol::Number: Tolerance to accept the perturbation when calculating   the Jacobian matrix. If the computed perturbation is lower than   jacobian_perturbation_tol, we increase it until it absolute value is higher than   jacobian_perturbation_tol.   (Default = 1e-7)\nmax_iterations::Int: Maximum number of iterations allowed for the least-square fitting.   (Default = 50)\nmean_elements_epoch::Number: Epoch for the fitted mean elements.   (Default = vjd[end])\nverbose::Bool: If true, the algorithm prints debugging information to stdout.   (Default = true)\nweight_vector::AbstractVector: Vector with the measurements weights for the least-square   algorithm. We assemble the weight matrix W as a diagonal matrix with the elements in   weight_vector at its diagonal.   (Default = @SVector(ones(Bool, 6)))\n\nReturns\n\nKeplerianElements{Float64, Float64}: Fitted Keplerian elements.\nSMatrix{6, 6, Float64}: Final covariance matrix of the least-square algorithm.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.Propagators.fit_mean_elements-Union{Tuple{Tv}, Tuple{Tjd}, Tuple{Val{:SGP4}, AbstractVector{Tjd}, AbstractVector{Tv}, AbstractVector{Tv}}} where {Tjd<:Number, Tv<:(AbstractVector)}","page":"Library","title":"SatelliteToolboxPropagators.Propagators.fit_mean_elements","text":"Propagators.fit_mean_elements(::Val{:SGP4}, vjd::AbstractVector{Tjd}, vr_teme::AbstractVector{Tv}, vv_teme::AbstractVector{Tv}; kwargs...) -> KeplerianElements{Float64, Float64}, SMatrix{6, 6, Float64}\n\nFit a Two-Line Element set (TLE) for the SGP4 orbit propagator using the osculating elements represented by a set of position vectors vr_teme [m] and a set of velocity vectors vv_teme [m / s] represented in the True-Equator, Mean-Equinox reference frame (TEME) at instants in the array vjd [Julian Day].\n\nThis algorithm was based on [1].\n\nnote: Note\nThis algorithm version will allocate a new SGP4 propagator with the default constants sgp4c_wgs84. If another set of constants are required, use the function Propagators.fit_mean_elements! instead.\n\nKeywords\n\natol::Number: Tolerance for the residue absolute value. If the residue is lower than   atol at any iteration, the computation loop stops.   (Default = 2e-4)\nrtol::Number: Tolerance for the relative difference between the residues. If the   relative difference between the residues in two consecutive iterations is lower than   rtol, the computation loop stops.   (Default = 2e-4)\nestimate_bstar::Bool: If true, the algorithm will try to estimate the B* parameter.   Otherwise, it will be set to 0 or to the value in initial guess (see section  Initial   Guess).   (Default = true)\ninitial_guess::Union{Nothing, AbstractVector, TLE}: Initial guess for the TLE fitting   process. If it is nothing, the algorithm will obtain an initial estimate from the   osculating elements in vr_teme and vv_teme. For more information, see the section   Initial Guess.   (Default = nothing)\njacobian_perturbation::Number: Initial state perturbation to compute the   finite-difference when calculating the Jacobian matrix.   (Default = 1e-3)\njacobian_perturbation_tol::Number: Tolerance to accept the perturbation when calculating   the Jacobian matrix. If the computed perturbation is lower than   jacobian_perturbation_tol, we increase it until it absolute value is higher than   jacobian_perturbation_tol.   (Default = 1e-7)\nmax_iterations::Int: Maximum number of iterations allowed for the least-square fitting.   (Default = 50)\nmean_elements_epoch::Number: Epoch for the fitted TLE.   (Default = vjd[end])\nverbose::Bool: If true, the algorithm prints debugging information to stdout.   (Default = true)\nweight_vector::AbstractVector: Vector with the measurements weights for the least-square   algorithm. We assemble the weight matrix W as a diagonal matrix with the elements in   weight_vector at its diagonal.   (Default = @SVector(ones(Bool, 6)))\nclassification::Char: Satellite classification character for the output TLE.   (Default = 'U')\nelement_set_number::Int: Element set number for the output TLE.   (Default = 0)\ninternational_designator::String: International designator string for the output TLE.   (Default = \"999999\")\nname::String: Satellite name for the output TLE.   (Default = \"UNDEFINED\")\nrevolution_number::Int: Revolution number for the output TLE.   (Default = 0)\nsatellite_number::Int: Satellite number for the output TLE.   (Default = 9999)\n\nReturns\n\nTLE: The fitted TLE.\nSMatrix{7, 7, T}: Final covariance matrix of the least-square algorithm.\n\nInitial Guess\n\nThis algorithm uses a least-square algorithm to fit a TLE based on a set of osculating state vectors. Since the system is chaotic, a good initial guess is paramount for algorithm convergence. We can provide an initial guess using the keyword initial_guess.\n\nIf initial_guess is a TLE, we update the TLE epoch using the function update_sgp4_tle_epoch! to the desired one in mean_elements_epoch. Afterward, we use this new TLE as the initial guess.\n\nIf initial_guess is an AbstractVector, we use this vector as the initial mean state vector for the algorithm. It must contain 7 elements as follows:\n\n┌                                    ┐\n│ IDs 1 to 3: Mean position [km]     │\n│ IDs 4 to 6: Mean velocity [km / s] │\n│ ID  7:      Bstar         [1 / er] │\n└                                    ┘\n\nIf initial_guess is nothing, the algorithm takes the closest osculating state vector to the mean_elements_epoch and uses it as the initial mean state vector. In this case, the epoch is set to the same epoch of the osculating data in vjd. When the fitted TLE is obtained, the algorithm uses the function update_sgp4_tle_epoch! to change its epoch to mean_elements_epoch.\n\nnote: Note\nIf initial_guess is not nothing, the B* initial estimate is obtained from the TLE or the state vector. Hence, if estimate_bstar is false, it will be kept constant with this initial value.\n\nReferences\n\n[1] Vallado, D. A., Crawford, P (2008). SGP4 Orbit Determination. American Institute   of Aeronautics ans Astronautics.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.Propagators.init!-Tuple{OrbitPropagatorJ2, KeplerianElements}","page":"Library","title":"SatelliteToolboxPropagators.Propagators.init!","text":"Propagators.init!(orbp::OrbitPropagatorJ2, orb₀::KeplerianElements) -> Nothing\n\nInitialize the J2 orbit propagator structure orbp using the mean Keplerian elements orb₀ [SI units].\n\nwarning: Warning\nThe propagation constants j2c::J2PropagatorConstants in orbp.j2d will not be changed. Hence, they must be initialized.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.Propagators.init!-Tuple{OrbitPropagatorJ2Osculating, KeplerianElements}","page":"Library","title":"SatelliteToolboxPropagators.Propagators.init!","text":"Propagators.init!(orbp::OrbitPropagatorJ2Osculating, orb₀::KeplerianElements) -> Nothing\n\nInitialize the J2 osculating orbit propagator structure orbp using the mean Keplerian elements orb₀ [SI units].\n\nwarning: Warning\nThe propagation constants j2c::J2PropagatorConstants in orbp.j2d will not be changed. Hence, they must be initialized.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.Propagators.init!-Tuple{OrbitPropagatorJ4, KeplerianElements}","page":"Library","title":"SatelliteToolboxPropagators.Propagators.init!","text":"Propagators.init!(orbp::OrbitPropagatorJ4, orb₀::KeplerianElements) -> Nothing\n\nInitialize the J4 orbit propagator structure orbp using the mean Keplerian elements orb₀.\n\nwarning: Warning\nThe propagation constants j4c::J4PropagatorConstants in j4d will not be changed. Hence, they must be initialized.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.Propagators.init!-Tuple{OrbitPropagatorJ4Osculating, KeplerianElements}","page":"Library","title":"SatelliteToolboxPropagators.Propagators.init!","text":"Propagators.init!(orbp::OrbitPropagatorJ4Osculating, orb₀::KeplerianElements) -> Nothing\n\nInitialize the J4 osculating orbit propagator structure orbp using the mean Keplerian elements orb₀.\n\nwarning: Warning\nThe propagation constants j4c::J4PropagatorConstants in orbp.j4d will not be changed. Hence, they must be initialized.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.Propagators.init!-Tuple{OrbitPropagatorSgp4, TLE}","page":"Library","title":"SatelliteToolboxPropagators.Propagators.init!","text":"Propagators.init!(orbp::OrbitPropagatorSgp4, epoch::Number, n₀::Number, e₀::Number, i₀::Number, Ω₀::Number, ω₀::Number, M₀::Number, bstar::Number; kwargs...) -> Nothing\nPropagators.init!(orbp::OrbitPropagatorSgp4, tle::TLE; kwargs...) -> Nothing\n\nInitialize the SGP4 orbit propagator structure orbp using the initial orbit specified by the arguments.\n\nwarning: Warning\nThe propagation constants sgp4c::Sgp4Constants in orbp.sgp4d will not be changed. Hence, they must be initialized.\n\nArguments\n\nepoch::Number: Epoch of the orbital elements [Julian Day].\nn₀::Number: SGP type \"mean\" mean motion at epoch [rad/s].\ne₀::Number: \"Mean\" eccentricity at epoch.\ni₀::Number: \"Mean\" inclination at epoch [rad].\nΩ₀::Number: \"Mean\" longitude of the ascending node at epoch [rad].\nω₀::Number: \"Mean\" argument of perigee at epoch [rad].\nM₀::Number: \"Mean\" mean anomaly at epoch [rad].\nbstar::Number: Drag parameter (B*).\ntle::TLE: Two-line elements used for the initialization.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.Propagators.init!-Tuple{OrbitPropagatorTwoBody, KeplerianElements}","page":"Library","title":"SatelliteToolboxPropagators.Propagators.init!","text":"Propagators.init!(orbp::OrbitPropagatorTwoBody, orb₀::KeplerianElements) -> Nothing\n\nInitialize the two-body orbit propagator structure orbp using the mean Keplerian elements orb₀.\n\nwarning: Warning\nThe propagation constant m0::Number in tbd will not be changed. Hence, it must be initialized.\n\nArguments\n\norb₀::KeplerianElements: Initial mean Keplerian elements [SI units].\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.Propagators.init-Tuple{Val{:J2osc}, KeplerianElements}","page":"Library","title":"SatelliteToolboxPropagators.Propagators.init","text":"Propagators.init(Val(:J2osc), orb₀::KeplerianElements; kwargs...) -> OrbitPropagatorJ2Osculating\n\nCreate and initialize the J2 osculating orbit propagator structure using the mean Keplerian elements orb₀ [SI units].\n\nnote: Note\nThe type used in the propagation will be the same as used to define the constants in the structure j2c.\n\nKeywords\n\nj2c::J2PropagatorConstants: J2 orbit propagator constants (see J2PropagatorConstants). (Default = j2c_egm2008)\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.Propagators.init-Tuple{Val{:J2}, KeplerianElements}","page":"Library","title":"SatelliteToolboxPropagators.Propagators.init","text":"Propagators.init(Val(:J2), orb₀::KeplerianElements; kwargs...) -> OrbitPropagatorJ2\n\nCreate and initialize the J2 orbit propagator structure using the mean Keplerian elements orb₀ [SI units].\n\nnote: Note\nThe type used in the propagation will be the same as used to define the constants in the structure j2c.\n\nKeywords\n\nj2c::J2PropagatorConstants: J2 orbit propagator constants (see J2PropagatorConstants). (Default = j2c_egm2008)\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.Propagators.init-Tuple{Val{:J4osc}, KeplerianElements}","page":"Library","title":"SatelliteToolboxPropagators.Propagators.init","text":"Propagators.init(Val(:J4osc), orb₀::KeplerianElements; kwargs...) -> OrbitPropagatorJ4Osculating\n\nCreate and initialize the J4 osculating orbit propagator structure using the mean Keplerian elements orb₀.\n\nnote: Note\nThe type used in the propagation will be the same as used to define the constants in the structure j4c.\n\nKeywords\n\nj4c::J4PropagatorConstants: J4 orbit propagator constants (see J4PropagatorConstants). (Default = j4c_egm2008)\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.Propagators.init-Tuple{Val{:J4}, KeplerianElements}","page":"Library","title":"SatelliteToolboxPropagators.Propagators.init","text":"Propagators.init(Val(:J4), orb₀::Orbit; kwargs...) -> OrbitPropagatorJ4\n\nCreate and initialize the J4 orbit propagator structure using the mean Keplerian elements orb₀.\n\nnote: Note\nThe type used in the propagation will be the same as used to define the constants in the structure j4c.\n\nKeywords\n\nj4c::J4PropagatorConstants: J4 orbit propagator constants (see   J4PropagatorConstants).   (Default = j4c_egm2008)\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.Propagators.init-Tuple{Val{:SGP4}, TLE}","page":"Library","title":"SatelliteToolboxPropagators.Propagators.init","text":"Propagators.init(Val(:SGP4), epoch::Number, n₀::Number, e₀::Number, i₀::Number, Ω₀::Number, ω₀::Number, M₀::Number, bstar::Number; kwargs...) -> OrbitPropagatorSgp4\nPropagators.init(Val(:SGP4), tle::TLE; kwargs...) -> OrbitPropagatorSgp4\n\nCreate and initialize the SGP4 orbit propagator structure using the initial orbit specified by the arguments.\n\nnote: Note\nThe type used in the propagation will be the same as used to define the constants in the structure sgp4c.\n\nArguments\n\nepoch::Number: Epoch of the orbital elements [Julian Day].\nn₀::Number: SGP type \"mean\" mean motion at epoch [rad/s].\ne₀::Number: \"Mean\" eccentricity at epoch.\ni₀::Number: \"Mean\" inclination at epoch [rad].\nΩ₀::Number: \"Mean\" longitude of the ascending node at epoch [rad].\nω₀::Number: \"Mean\" argument of perigee at epoch [rad].\nM₀::Number: \"Mean\" mean anomaly at epoch [rad].\nbstar::Number: Drag parameter (B*).\ntle::TLE: Two-line elements used for the initialization.\n\nKeywords\n\nsgp4c::Sgp4Constants: SGP4 orbit propagator constants (see Sgp4Constants).   (Default = sgp4c_wgs84)\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.Propagators.init-Tuple{Val{:TwoBody}, KeplerianElements}","page":"Library","title":"SatelliteToolboxPropagators.Propagators.init","text":"Propagators.init(Val(:TwoBody), orb₀::KeplerianElements; kwargs...) -> OrbitPropagatorTwoBody\n\nCreate and initialize the two-body orbit propagator structure using the mean Keplerian elements orb₀.\n\nnote: Note\nThe type used in the propagation will be the same as used to define the gravitational constant m0.\n\nKeywords\n\nm0::T: Standard gravitational parameter of the central body [m³ / s²].   (Default = tbc_m0)\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators._j2_jacobian-Union{Tuple{Tepoch}, Tuple{T}, Tuple{J2Propagator{Tepoch, T}, Number, StaticArraysCore.SVector{6, T}, StaticArraysCore.SVector{6, T}}} where {T<:Number, Tepoch<:Number}","page":"Library","title":"SatelliteToolboxPropagators._j2_jacobian","text":"_j2_jacobian(j2d::J2OsculatingPropagator{Tepoch, T}, Δt::Number, x₁::SVector{6, T}, y₁::SVector{6, T}; kwargs...)) where {T<:Number, Tepoch<:Number} -> SMatrix{6, 6, T}\n\nCompute the J2 orbit propagator Jacobian by finite-differences using the propagator j2d at instant Δt considering the input mean elements x₁ that must provide the output vector y₁. Hence:\n\n    ∂j2(x, Δt) │\nJ = ────────── │\n        ∂x     │ x = x₁\n\nKeywords\n\nperturbation::T: Initial state perturbation to compute the finite-difference:   Δx = x * perturbation.   (Default = 1e-3)\nperturbation_tol::T: Tolerance to accept the perturbation. If the computed perturbation   is lower than perturbation_tol, we increase it until it absolute value is higher than   perturbation_tol.   (Default = 1e-7)\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators._j2osc_jacobian-Union{Tuple{Tepoch}, Tuple{T}, Tuple{J2OsculatingPropagator{Tepoch, T}, Number, StaticArraysCore.SVector{6, T}, StaticArraysCore.SVector{6, T}}} where {T<:Number, Tepoch<:Number}","page":"Library","title":"SatelliteToolboxPropagators._j2osc_jacobian","text":"_j2osc_jacobian(j2oscd::J2OsculatingPropagator{Tepoch, T}, Δt::Number, x₁::SVector{6, T}, y₁::SVector{6, T}; kwargs...)) where {T<:Number, Tepoch<:Number} -> SMatrix{6, 6, T}\n\nCompute the J2 osculating orbit propagator Jacobian by finite-differences using the propagator j2oscd at instant Δt considering the input mean elements x₁ that must provide the output vector y₁. Hence:\n\n    ∂j2osc(x, Δt) │\nJ = ───────────── │\n          ∂x      │ x = x₁\n\nKeywords\n\nperturbation::T: Initial state perturbation to compute the finite-difference:   Δx = x * perturbation.   (Default = 1e-3)\nperturbation_tol::T: Tolerance to accept the perturbation. If the computed perturbation   is lower than perturbation_tol, we increase it until it absolute value is higher than   perturbation_tol.   (Default = 1e-7)\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators._j4_jacobian-Union{Tuple{Tepoch}, Tuple{T}, Tuple{J4Propagator{Tepoch, T}, Number, StaticArraysCore.SVector{6, T}, StaticArraysCore.SVector{6, T}}} where {T<:Number, Tepoch<:Number}","page":"Library","title":"SatelliteToolboxPropagators._j4_jacobian","text":"_j4_jacobian(j4d::J4OsculatingPropagator{Tepoch, T}, Δt::Number, x₁::SVector{6, T}, y₁::SVector{6, T}; kwargs...)) where {T<:Number, Tepoch<:Number} -> SMatrix{6, 6, T}\n\nCompute the J4 orbit propagator Jacobian by finite-differences using the propagator j4d at instant Δt considering the input mean elements x₁ that must provide the output vector y₁. Hence:\n\n    ∂j4(x, Δt) │\nJ = ────────── │\n        ∂x     │ x = x₁\n\nKeywords\n\nperturbation::T: Initial state perturbation to compute the finite-difference:   Δx = x * perturbation.   (Default = 1e-3)\nperturbation_tol::T: Tolerance to accept the perturbation. If the computed perturbation   is lower than perturbation_tol, we increase it until it absolute value is higher than   perturbation_tol.   (Default = 1e-7)\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators._j4osc_jacobian-Union{Tuple{Tepoch}, Tuple{T}, Tuple{J4OsculatingPropagator{Tepoch, T}, Number, StaticArraysCore.SVector{6, T}, StaticArraysCore.SVector{6, T}}} where {T<:Number, Tepoch<:Number}","page":"Library","title":"SatelliteToolboxPropagators._j4osc_jacobian","text":"_j4osc_jacobian(j4oscd::J4OsculatingPropagator{Tepoch, T}, Δt::Number, x₁::SVector{6, T}, y₁::SVector{6, T}; kwargs...)) where {T<:Number, Tepoch<:Number} -> SMatrix{6, 6, T}\n\nCompute the J4 osculating orbit propagator Jacobian by finite-differences using the propagator j4oscd at instant Δt considering the input mean elements x₁ that must provide the output vector y₁. Hence:\n\n    ∂j4osc(x, Δt) │\nJ = ───────────── │\n          ∂x      │ x = x₁\n\nKeywords\n\nperturbation::T: Initial state perturbation to compute the finite-difference:   Δx = x * perturbation.   (Default = 1e-3)\nperturbation_tol::T: Tolerance to accept the perturbation. If the computed perturbation   is lower than perturbation_tol, we increase it until it absolute value is higher than   perturbation_tol.   (Default = 1e-7)\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.fit_j2_mean_elements!-Union{Tuple{Tv}, Tuple{Tjd}, Tuple{Tepoch}, Tuple{T}, Tuple{J2Propagator{Tepoch, T}, AbstractVector{Tjd}, AbstractVector{Tv}, AbstractVector{Tv}}} where {T<:Number, Tepoch<:Number, Tjd<:Number, Tv<:(AbstractVector)}","page":"Library","title":"SatelliteToolboxPropagators.fit_j2_mean_elements!","text":"fit_j2_mean_elements!(j2d::J2Propagator{Tepoch, T}, vjd::AbstractVector{Tjd}, vr_i::AbstractVector{Tv}, vv_i::AbstractVector{Tv}; kwargs...) where {T<:Number, Tepoch<:Number, Tjd<:Number, Tv<:AbstractVector} -> KeplerianElements{Tepoch, T}, SMatrix{6, 6, T}\n\nFit a set of mean Keplerian elements for the J2 orbit propagator j2d using the osculating elements represented by a set of position vectors vr_i [m] and a set of velocity vectors vv_i [m / s] represented in an inertial reference frame at instants in the array vjd [Julian Day].\n\nnote: Note\nThe J2 orbit propagator j2d will be initialized with the Keplerian elements returned by the function.\n\nKeywords\n\natol::Number: Tolerance for the residue absolute value. If the residue is lower than   atol at any iteration, the computation loop stops.   (Default = 2e-4)\nrtol::Number: Tolerance for the relative difference between the residues. If the   relative difference between the residues in two consecutive iterations is lower than   rtol, the computation loop stops.   (Default = 2e-4)\ninitial_guess::Union{Nothing, KeplerianElements}: Initial guess for the mean elements   fitting process. If it is nothing, the algorithm will obtain an initial estimate from   the osculating elements in vr_i and vv_i.   (Default = nothing)\njacobian_perturbation::Number: Initial state perturbation to compute the   finite-difference when calculating the Jacobian matrix.   (Default = 1e-3)\njacobian_perturbation_tol::Number: Tolerance to accept the perturbation when calculating   the Jacobian matrix. If the computed perturbation is lower than   jacobian_perturbation_tol, we increase it until it absolute value is higher than   jacobian_perturbation_tol.   (Default = 1e-7)\nmax_iterations::Int: Maximum number of iterations allowed for the least-square fitting.   (Default = 50)\nmean_elements_epoch::Number: Epoch for the fitted mean elements.   (Default = vjd[end])\nverbose::Bool: If true, the algorithm prints debugging information to stdout.   (Default = true)\nweight_vector::AbstractVector: Vector with the measurements weights for the least-square   algorithm. We assemble the weight matrix W as a diagonal matrix with the elements in   weight_vector at its diagonal.   (Default = @SVector(ones(Bool, 6)))\n\nReturns\n\nKeplerianElements{Tepoch, T}: Fitted Keplerian elements.\nSMatrix{6, 6, T}: Final covariance matrix of the least-square algorithm.\n\nExamples\n\n# Allocate a new J2 orbit propagator using a dummy Keplerian elements.\njulia> j2d = j2_init(KeplerianElements{Float64, Float64}(0, 7000e3, 0, 0, 0, 0, 0));\n\njulia> vr_i = [\n           [-6792.402703741442, 2192.6458461287293, 0.18851758695295118]  .* 1000,\n           [-1781.214419290065, 1619.7795321872854, 6707.771633846665]    .* 1000,\n           [ 5693.643675547716, -1192.342828671633, 4123.976025977494]    .* 1000,\n           [ 5291.613719530499, -2354.5417593130833, -4175.561367156414]  .* 1000,\n           [-2416.3705905186903, -268.74923235392623, -6715.411357310478] .* 1000,\n           [-6795.043410709359, 2184.4414321930635, -0.4327055325971031]  .* 1000,\n       ];\n\njulia> vv_i = [\n           [0.3445760107690598, 1.0395135806993514, 7.393686131436984]    .* 1000,\n           [6.875680282038698, -1.864319399615942, 2.270603214569518]     .* 1000,\n           [3.8964090757666496, -2.1887896252945875, -5.9960180359219075] .* 1000,\n           [-4.470258022565413, 0.5119576359985208, -5.9608372367141635]  .* 1000,\n           [-6.647358060413909, 2.495415251255861, 2.292118747543002]     .* 1000,\n           [0.3427096905434428, 1.040125572862349, 7.3936887585116855]    .* 1000,\n       ];\n\njulia> vjd = [\n           2.46002818657856e6\n           2.460028200467449e6\n           2.460028214356338e6\n           2.4600282282452267e6\n           2.4600282421341157e6\n           2.4600282560230047e6\n       ];\n\njulia> orb, P = fit_j2_mean_elements!(j2d, vjd, vr_i, vv_i)\nACTION:   Fitting the mean elements for the J2 propagator.\n           Iteration        Position RMSE        Velocity RMSE           Total RMSE       RMSE Variation\n                                     [km]             [km / s]                  [ ]\nPROGRESS:         23               4.3413           0.00540076              4341.31         -2.90721e-06 %\n\n(KeplerianElements{Float64, Float64}: Epoch = 2.46003e6 (2023-03-24T18:08:40.388), [0.16604846233666615 0.06643574144803302 … -3.85541368066423e-5 0.000124032254172014; 0.0664357414470214 0.26633448262787296 … -1.7943612056596758e-5 -1.9567956793856743e-5; … ; -3.855413680493565e-5 -1.7943612058983507e-5 … 4.3971984339116176e-7 -8.092704691911699e-8; 0.0001240322541726098 -1.9567956793417353e-5 … -8.092704692135158e-8 1.2451922454639337e-7])\n\njulia> orb\nKeplerianElements{Float64, Float64}:\n           Epoch :    2.46003e6 (2023-03-24T18:08:40.388)\n Semi-major axis : 7131.63       km\n    Eccentricity :    0.00114299\n     Inclination :   98.4366     °\n            RAAN :  162.177      °\n Arg. of Perigee :  101.286      °\n    True Anomaly :  258.689      °\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.fit_j2_mean_elements-Union{Tuple{Tv}, Tuple{Tjd}, Tuple{AbstractVector{Tjd}, AbstractVector{Tv}, AbstractVector{Tv}}} where {Tjd<:Number, Tv<:(AbstractVector)}","page":"Library","title":"SatelliteToolboxPropagators.fit_j2_mean_elements","text":"fit_j2_mean_elements(vjd::AbstractVector{Tjd}, vr_i::AbstractVector{Tv}, vv_i::AbstractVector{Tv}; kwargs...) where {Tjd<:Number, Tv<:AbstractVector} -> KeplerianElements{Float64, Float64}, SMatrix{6, 6, Float64}\n\nFit a set of mean Keplerian elements for the J2 orbit propagator using the osculating elements represented by a set of position vectors vr_i [m] and a set of velocity vectors vv_i [m / s] represented in an inertial reference frame at instants in the array vjd [Julian Day].\n\nnote: Note\nThis algorithm version will allocate a new J2 propagator with the default constants j2c_egm2008. If another set of constants are required, use the function fit_j2_mean_elements! instead.\n\nKeywords\n\natol::Number: Tolerance for the residue absolute value. If the residue is lower than   atol at any iteration, the computation loop stops.   (Default = 2e-4)\nrtol::Number: Tolerance for the relative difference between the residues. If the   relative difference between the residues in two consecutive iterations is lower than   rtol, the computation loop stops.   (Default = 2e-4)\ninitial_guess::Union{Nothing, KeplerianElements}: Initial guess for the mean elements   fitting process. If it is nothing, the algorithm will obtain an initial estimate from   the osculating elements in vr_i and vv_i.   (Default = nothing)\njacobian_perturbation::Number: Initial state perturbation to compute the   finite-difference when calculating the Jacobian matrix.   (Default = 1e-3)\njacobian_perturbation_tol::Number: Tolerance to accept the perturbation when calculating   the Jacobian matrix. If the computed perturbation is lower than   jacobian_perturbation_tol, we increase it until it absolute value is higher than   jacobian_perturbation_tol.   (Default = 1e-7)\nmax_iterations::Int: Maximum number of iterations allowed for the least-square fitting.   (Default = 50)\nmean_elements_epoch::Number: Epoch for the fitted mean elements.   (Default = vjd[end])\nverbose::Bool: If true, the algorithm prints debugging information to stdout.   (Default = true)\nweight_vector::AbstractVector: Vector with the measurements weights for the least-square   algorithm. We assemble the weight matrix W as a diagonal matrix with the elements in   weight_vector at its diagonal.   (Default = @SVector(ones(Bool, 6)))\n\nReturns\n\nKeplerianElements{Float64, Float64}: Fitted Keplerian elements.\nSMatrix{6, 6, Float64}: Final covariance matrix of the least-square algorithm.\n\nExamples\n\njulia> vr_i = [\n           [-6792.402703741442, 2192.6458461287293, 0.18851758695295118]  .* 1000,\n           [-1781.214419290065, 1619.7795321872854, 6707.771633846665]    .* 1000,\n           [ 5693.643675547716, -1192.342828671633, 4123.976025977494]    .* 1000,\n           [ 5291.613719530499, -2354.5417593130833, -4175.561367156414]  .* 1000,\n           [-2416.3705905186903, -268.74923235392623, -6715.411357310478] .* 1000,\n           [-6795.043410709359, 2184.4414321930635, -0.4327055325971031]  .* 1000,\n       ];\n\njulia> vv_i = [\n           [0.3445760107690598, 1.0395135806993514, 7.393686131436984]    .* 1000,\n           [6.875680282038698, -1.864319399615942, 2.270603214569518]     .* 1000,\n           [3.8964090757666496, -2.1887896252945875, -5.9960180359219075] .* 1000,\n           [-4.470258022565413, 0.5119576359985208, -5.9608372367141635]  .* 1000,\n           [-6.647358060413909, 2.495415251255861, 2.292118747543002]     .* 1000,\n           [0.3427096905434428, 1.040125572862349, 7.3936887585116855]    .* 1000,\n       ];\n\njulia> vjd = [\n           2.46002818657856e6\n           2.460028200467449e6\n           2.460028214356338e6\n           2.4600282282452267e6\n           2.4600282421341157e6\n           2.4600282560230047e6\n       ];\n\njulia> orb, P = fit_j2_mean_elements(vjd, vr_i, vv_i)\nACTION:   Fitting the mean elements for the J2 propagator.\n           Iteration        Position RMSE        Velocity RMSE           Total RMSE       RMSE Variation\n                                     [km]             [km / s]                  [ ]\nPROGRESS:         23               4.3413           0.00540076              4341.31         -2.90721e-06 %\n\n(KeplerianElements{Float64, Float64}: Epoch = 2.46003e6 (2023-03-24T18:08:40.388), [0.16604846233666615 0.06643574144803302 … -3.85541368066423e-5 0.000124032254172014; 0.0664357414470214 0.26633448262787296 … -1.7943612056596758e-5 -1.9567956793856743e-5; … ; -3.855413680493565e-5 -1.7943612058983507e-5 … 4.3971984339116176e-7 -8.092704691911699e-8; 0.0001240322541726098 -1.9567956793417353e-5 … -8.092704692135158e-8 1.2451922454639337e-7])\n\njulia> orb\nKeplerianElements{Float64, Float64}:\n           Epoch :    2.46003e6 (2023-03-24T18:08:40.388)\n Semi-major axis : 7131.63       km\n    Eccentricity :    0.00114299\n     Inclination :   98.4366     °\n            RAAN :  162.177      °\n Arg. of Perigee :  101.286      °\n    True Anomaly :  258.689      °\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.fit_j2osc_mean_elements!-Union{Tuple{Tv}, Tuple{Tjd}, Tuple{Tepoch}, Tuple{T}, Tuple{J2OsculatingPropagator{Tepoch, T}, AbstractVector{Tjd}, AbstractVector{Tv}, AbstractVector{Tv}}} where {T<:Number, Tepoch<:Number, Tjd<:Number, Tv<:(AbstractVector)}","page":"Library","title":"SatelliteToolboxPropagators.fit_j2osc_mean_elements!","text":"fit_j2osc_mean_elements!(j2oscd::J2OsculatingPropagator{Tepoch, T}, vjd::AbstractVector{Tjd}, vr_i::AbstractVector{Tv}, vv_i::AbstractVector{Tv}; kwargs...) where {T<:Number, Tepoch<:Number, Tjd<:Number, Tv<:AbstractVector} -> KeplerianElements{Tepoch, T}, SMatrix{6, 6, T}\n\nFit a set of mean Keplerian elements for the J2 osculating orbit propagator j2oscd using the osculating elements represented by a set of position vectors vr_i [m] and a set of velocity vectors vv_i [m / s] represented in an inertial reference frame at instants in the array vjd [Julian Day].\n\nnote: Note\nThe J2 osculating orbit propagator j2oscd will be initialized with the Keplerian elements returned by the function.\n\nKeywords\n\natol::Number: Tolerance for the residue absolute value. If the residue is lower than   atol at any iteration, the computation loop stops.   (Default = 2e-4)\nrtol::Number: Tolerance for the relative difference between the residues. If the   relative difference between the residues in two consecutive iterations is lower than   rtol, the computation loop stops.   (Default = 2e-4)\ninitial_guess::Union{Nothing, KeplerianElements}: Initial guess for the mean elements   fitting process. If it is nothing, the algorithm will obtain an initial estimate from   the osculating elements in vr_i and vv_i.   (Default = nothing)\njacobian_perturbation::Number: Initial state perturbation to compute the   finite-difference when calculating the Jacobian matrix.   (Default = 1e-3)\njacobian_perturbation_tol::Number: Tolerance to accept the perturbation when calculating   the Jacobian matrix. If the computed perturbation is lower than   jacobian_perturbation_tol, we increase it until it absolute value is higher than   jacobian_perturbation_tol.   (Default = 1e-7)\nmax_iterations::Int: Maximum number of iterations allowed for the least-square fitting.   (Default = 50)\nmean_elements_epoch::Number: Epoch for the fitted mean elements.   (Default = vjd[end])\nverbose::Bool: If true, the algorithm prints debugging information to stdout.   (Default = true)\nweight_vector::AbstractVector: Vector with the measurements weights for the least-square   algorithm. We assemble the weight matrix W as a diagonal matrix with the elements in   weight_vector at its diagonal.   (Default = @SVector(ones(Bool, 6)))\n\nReturns\n\nKeplerianElements{Tepoch, T}: Fitted Keplerian elements.\nSMatrix{6, 6, T}: Final covariance matrix of the least-square algorithm.\n\nExamples\n\n# Allocate a new J2 osculating orbit propagator using a dummy Keplerian elements.\njulia> j2oscd = j2osc_init(KeplerianElements{Float64, Float64}(0, 7000e3, 0, 0, 0, 0, 0));\n\njulia> vr_i = [\n           [-6792.402703741442, 2192.6458461287293, 0.18851758695295118] .* 1000,\n           [-6357.88873265975, 2391.9476768911686, 2181.838771262736] .* 1000\n       ];\n\njulia> vv_i = [\n           [0.3445760107690598, 1.0395135806993514, 7.393686131436984] .* 1000,\n           [2.5285015912807003, 0.27812476784300005, 7.030323100703928] .* 1000\n       ];\n\njulia> vjd = [\n           2.46002818657856e6,\n           2.460028190050782e6\n       ];\n\njulia> orb, P = fit_j2osc_mean_elements!(j2oscd, vjd, vr_i, vv_i)\nACTION:   Fitting the mean elements for the J2 osculating propagator.\n           Iteration        Position RMSE        Velocity RMSE           Total RMSE       RMSE Variation\n                                     [km]             [km / s]                  [ ]\nPROGRESS:          4          1.69161e-05           0.00260193              2.60198         -2.06772e-09 %\n\n(KeplerianElements{Float64, Float64}: Epoch = 2.46003e6 (2023-03-24T16:33:40.388), [0.9999427882949705 -0.0049011518111948425 … -0.00012021282848110985 -0.00011550570919063845; -0.00490115181520327 1.0007325785722665 … 0.0032661568999667063 3.8567115793316056e-5; … ; -0.00012021282849269182 0.003266156899966125 … 2.204826778451109e-5 5.382733068487529e-8; -0.00011550570919086411 3.8567115786674836e-5 … 5.382733066340212e-8 2.1657420198753813e-5])\n\njulia> orb\nKeplerianElements{Float64, Float64}:\n           Epoch :    2.46003e6 (2023-03-24T16:33:40.388)\n Semi-major axis : 7135.8        km\n    Eccentricity :    0.00135383\n     Inclination :   98.4304     °\n            RAAN :  162.113      °\n Arg. of Perigee :   64.9256     °\n    True Anomaly :  313.085      °\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.fit_j2osc_mean_elements-Union{Tuple{Tv}, Tuple{Tjd}, Tuple{AbstractVector{Tjd}, AbstractVector{Tv}, AbstractVector{Tv}}} where {Tjd<:Number, Tv<:(AbstractVector)}","page":"Library","title":"SatelliteToolboxPropagators.fit_j2osc_mean_elements","text":"fit_j2osc_mean_elements(vjd::AbstractVector{Tjd}, vr_i::AbstractVector{Tv}, vv_i::AbstractVector{Tv}; kwargs...) where {Tjd<:Number, Tv<:AbstractVector} -> KeplerianElements{Float64, Float64}, SMatrix{6, 6, Float64}\n\nFit a set of mean Keplerian elements for the J2 osculating orbit propagator using the osculating elements represented by a set of position vectors vr_i [m] and a set of velocity vectors vv_i [m / s] represented in an inertial reference frame at instants in the array vjd [Julian Day].\n\nnote: Note\nThis algorithm version will allocate a new J2 osculating propagator with the default constants j2c_egm2008. If another set of constants are required, use the function fit_j2osc_mean_elements! instead.\n\nKeywords\n\natol::Number: Tolerance for the residue absolute value. If the residue is lower than   atol at any iteration, the computation loop stops.   (Default = 2e-4)\nrtol::Number: Tolerance for the relative difference between the residues. If the   relative difference between the residues in two consecutive iterations is lower than   rtol, the computation loop stops.   (Default = 2e-4)\ninitial_guess::Union{Nothing, KeplerianElements}: Initial guess for the mean elements   fitting process. If it is nothing, the algorithm will obtain an initial estimate from   the osculating elements in vr_i and vv_i.   (Default = nothing)\njacobian_perturbation::Number: Initial state perturbation to compute the   finite-difference when calculating the Jacobian matrix.   (Default = 1e-3)\njacobian_perturbation_tol::Number: Tolerance to accept the perturbation when calculating   the Jacobian matrix. If the computed perturbation is lower than   jacobian_perturbation_tol, we increase it until it absolute value is higher than   jacobian_perturbation_tol.   (Default = 1e-7)\nmax_iterations::Int: Maximum number of iterations allowed for the least-square fitting.   (Default = 50)\nmean_elements_epoch::Number: Epoch for the fitted mean elements.   (Default = vjd[end])\nverbose::Bool: If true, the algorithm prints debugging information to stdout.   (Default = true)\nweight_vector::AbstractVector: Vector with the measurements weights for the least-square   algorithm. We assemble the weight matrix W as a diagonal matrix with the elements in   weight_vector at its diagonal.   (Default = @SVector(ones(Bool, 6)))\n\nReturns\n\nKeplerianElements{Float64, Float64}: Fitted Keplerian elements.\nSMatrix{6, 6, Float64}: Final covariance matrix of the least-square algorithm.\n\nExamples\n\njulia> vr_i = [\n           [-6792.402703741442, 2192.6458461287293, 0.18851758695295118] .* 1000,\n           [-6357.88873265975, 2391.9476768911686, 2181.838771262736] .* 1000\n       ];\n\njulia> vv_i = [\n           [0.3445760107690598, 1.0395135806993514, 7.393686131436984] .* 1000,\n           [2.5285015912807003, 0.27812476784300005, 7.030323100703928] .* 1000\n       ];\n\njulia> vjd = [\n           2.46002818657856e6,\n           2.460028190050782e6\n       ];\n\njulia> orb, P = fit_j2osc_mean_elements(vjd, vr_i, vv_i)\nACTION:   Fitting the mean elements for the J2 osculating propagator.\n           Iteration        Position RMSE        Velocity RMSE           Total RMSE       RMSE Variation\n                                     [km]             [km / s]                  [ ]\nPROGRESS:          4          1.69161e-05           0.00260193              2.60198         -2.06772e-09 %\n\n(KeplerianElements{Float64, Float64}: Epoch = 2.46003e6 (2023-03-24T16:33:40.388), [0.9999427882949705 -0.0049011518111948425 … -0.00012021282848110985 -0.00011550570919063845; -0.00490115181520327 1.0007325785722665 … 0.0032661568999667063 3.8567115793316056e-5; … ; -0.00012021282849269182 0.003266156899966125 … 2.204826778451109e-5 5.382733068487529e-8; -0.00011550570919086411 3.8567115786674836e-5 … 5.382733066340212e-8 2.1657420198753813e-5])\n\njulia> orb\nKeplerianElements{Float64, Float64}:\n           Epoch :    2.46003e6 (2023-03-24T16:33:40.388)\n Semi-major axis : 7135.8        km\n    Eccentricity :    0.00135383\n     Inclination :   98.4304     °\n            RAAN :  162.113      °\n Arg. of Perigee :   64.9256     °\n    True Anomaly :  313.085      °\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.fit_j4_mean_elements!-Union{Tuple{Tv}, Tuple{Tjd}, Tuple{Tepoch}, Tuple{T}, Tuple{J4Propagator{Tepoch, T}, AbstractVector{Tjd}, AbstractVector{Tv}, AbstractVector{Tv}}} where {T<:Number, Tepoch<:Number, Tjd<:Number, Tv<:(AbstractVector)}","page":"Library","title":"SatelliteToolboxPropagators.fit_j4_mean_elements!","text":"fit_j4_mean_elements!(j4d::J4Propagator{Tepoch, T}, vjd::AbstractVector{Tjd}, vr_i::AbstractVector{Tv}, vv_i::AbstractVector{Tv}; kwargs...) where {T<:Number, Tepoch<:Number, Tjd<:Number, Tv<:AbstractVector} -> KeplerianElements{Tepoch, T}, SMatrix{6, 6, T}\n\nFit a set of mean Keplerian elements for the J4 orbit propagator j4d using the osculating elements represented by a set of position vectors vr_i [m] and a set of velocity vectors vv_i [m / s] represented in an inertial reference frame at instants in the array vjd [Julian Day].\n\nnote: Note\nThe J4 orbit propagator j4d will be initialized with the Keplerian elements returned by the function.\n\nKeywords\n\natol::Number: Tolerance for the residue absolute value. If the residue is lower than   atol at any iteration, the computation loop stops.   (Default = 2e-4)\nrtol::Number: Tolerance for the relative difference between the residues. If the   relative difference between the residues in two consecutive iterations is lower than   rtol, the computation loop stops.   (Default = 2e-4)\ninitial_guess::Union{Nothing, KeplerianElements}: Initial guess for the mean elements   fitting process. If it is nothing, the algorithm will obtain an initial estimate from   the osculating elements in vr_i and vv_i.   (Default = nothing)\njacobian_perturbation::Number: Initial state perturbation to compute the   finite-difference when calculating the Jacobian matrix.   (Default = 1e-3)\njacobian_perturbation_tol::Number: Tolerance to accept the perturbation when calculating   the Jacobian matrix. If the computed perturbation is lower than   jacobian_perturbation_tol, we increase it until it absolute value is higher than   jacobian_perturbation_tol.   (Default = 1e-7)\nmax_iterations::Int: Maximum number of iterations allowed for the least-square fitting.   (Default = 50)\nmean_elements_epoch::Number: Epoch for the fitted mean elements.   (Default = vjd[end])\nverbose::Bool: If true, the algorithm prints debugging information to stdout.   (Default = true)\nweight_vector::AbstractVector: Vector with the measurements weights for the least-square   algorithm. We assemble the weight matrix W as a diagonal matrix with the elements in   weight_vector at its diagonal.   (Default = @SVector(ones(Bool, 6)))\n\nReturns\n\nKeplerianElements{Tepoch, T}: Fitted Keplerian elements.\nSMatrix{6, 6, T}: Final covariance matrix of the least-square algorithm.\n\nExamples\n\n# Allocate a new J4 orbit propagator using a dummy Keplerian elements.\njulia> j4d = j4_init(KeplerianElements{Float64, Float64}(0, 7000e3, 0, 0, 0, 0, 0));\n\njulia> vr_i = [\n           [-6792.402703741442, 2192.6458461287293, 0.18851758695295118]  .* 1000,\n           [-1781.214419290065, 1619.7795321872854, 6707.771633846665]    .* 1000,\n           [ 5693.643675547716, -1192.342828671633, 4123.976025977494]    .* 1000,\n           [ 5291.613719530499, -2354.5417593130833, -4175.561367156414]  .* 1000,\n           [-2416.3705905186903, -268.74923235392623, -6715.411357310478] .* 1000,\n           [-6795.043410709359, 2184.4414321930635, -0.4327055325971031]  .* 1000,\n       ];\n\njulia> vv_i = [\n           [0.3445760107690598, 1.0395135806993514, 7.393686131436984]    .* 1000,\n           [6.875680282038698, -1.864319399615942, 2.270603214569518]     .* 1000,\n           [3.8964090757666496, -2.1887896252945875, -5.9960180359219075] .* 1000,\n           [-4.470258022565413, 0.5119576359985208, -5.9608372367141635]  .* 1000,\n           [-6.647358060413909, 2.495415251255861, 2.292118747543002]     .* 1000,\n           [0.3427096905434428, 1.040125572862349, 7.3936887585116855]    .* 1000,\n       ];\n\njulia> vjd = [\n           2.46002818657856e6\n           2.460028200467449e6\n           2.460028214356338e6\n           2.4600282282452267e6\n           2.4600282421341157e6\n           2.4600282560230047e6\n       ];\n\njulia> orb, P = fit_j4_mean_elements!(j4d, vjd, vr_i, vv_i)\nACTION:   Fitting the mean elements for the J4 propagator.\n           Iteration        Position RMSE        Velocity RMSE           Total RMSE       RMSE Variation\n                                     [km]             [km / s]                  [ ]\nPROGRESS:         23              4.33863           0.00539962              4338.63         -2.90777e-06 %\n\n(KeplerianElements{Float64, Float64}: Epoch = 2.46003e6 (2023-03-24T18:08:40.388), [0.16604866262321472 0.06643593039980161 … -3.8553206984036995e-5 0.00012403204426258087; 0.06643593040175688 0.26633435614867085 … -1.7942563356579497e-5 -1.95681107792859e-5; … ; -3.855320698470177e-5 -1.794256335557519e-5 … 4.3972013198895673e-7 -8.092682623169118e-8; 0.000124032044261828 -1.9568110780915995e-5 … -8.092682623078798e-8 1.2451901466558624e-7])\n\njulia> orb\nKeplerianElements{Float64, Float64}:\n           Epoch :    2.46003e6 (2023-03-24T18:08:40.388)\n Semi-major axis : 7131.64       km\n    Eccentricity :    0.00114298\n     Inclination :   98.4366     °\n            RAAN :  162.177      °\n Arg. of Perigee :  101.282      °\n    True Anomaly :  258.693      °\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.fit_j4_mean_elements-Union{Tuple{Tv}, Tuple{Tjd}, Tuple{AbstractVector{Tjd}, AbstractVector{Tv}, AbstractVector{Tv}}} where {Tjd<:Number, Tv<:(AbstractVector)}","page":"Library","title":"SatelliteToolboxPropagators.fit_j4_mean_elements","text":"fit_j4_mean_elements(vjd::AbstractVector{Tjd}, vr_i::AbstractVector{Tv}, vv_i::AbstractVector{Tv}; kwargs...) where {Tjd<:Number, Tv<:AbstractVector} -> KeplerianElements{Float64, Float64}, SMatrix{6, 6, Float64}\n\nFit a set of mean Keplerian elements for the J4 orbit propagator using the osculating elements represented by a set of position vectors vr_i [m] and a set of velocity vectors vv_i [m / s] represented in an inertial reference frame at instants in the array vjd [Julian Day].\n\nnote: Note\nThis algorithm version will allocate a new J4 propagator with the default constants j4c_egm2008. If another set of constants are required, use the function fit_j4_mean_elements! instead.\n\nKeywords\n\natol::Number: Tolerance for the residue absolute value. If the residue is lower than   atol at any iteration, the computation loop stops.   (Default = 2e-4)\nrtol::Number: Tolerance for the relative difference between the residues. If the   relative difference between the residues in two consecutive iterations is lower than   rtol, the computation loop stops.   (Default = 2e-4)\ninitial_guess::Union{Nothing, KeplerianElements}: Initial guess for the mean elements   fitting process. If it is nothing, the algorithm will obtain an initial estimate from   the osculating elements in vr_i and vv_i.   (Default = nothing)\njacobian_perturbation::Number: Initial state perturbation to compute the   finite-difference when calculating the Jacobian matrix.   (Default = 1e-3)\njacobian_perturbation_tol::Number: Tolerance to accept the perturbation when calculating   the Jacobian matrix. If the computed perturbation is lower than   jacobian_perturbation_tol, we increase it until it absolute value is higher than   jacobian_perturbation_tol.   (Default = 1e-7)\nmax_iterations::Int: Maximum number of iterations allowed for the least-square fitting.   (Default = 50)\nmean_elements_epoch::Number: Epoch for the fitted mean elements.   (Default = vjd[end])\nverbose::Bool: If true, the algorithm prints debugging information to stdout.   (Default = true)\nweight_vector::AbstractVector: Vector with the measurements weights for the least-square   algorithm. We assemble the weight matrix W as a diagonal matrix with the elements in   weight_vector at its diagonal.   (Default = @SVector(ones(Bool, 6)))\n\nReturns\n\nKeplerianElements{Float64, Float64}: Fitted Keplerian elements.\nSMatrix{6, 6, Float64}: Final covariance matrix of the least-square algorithm.\n\nExamples\n\njulia> vr_i = [\n           [-6792.402703741442, 2192.6458461287293, 0.18851758695295118]  .* 1000,\n           [-1781.214419290065, 1619.7795321872854, 6707.771633846665]    .* 1000,\n           [ 5693.643675547716, -1192.342828671633, 4123.976025977494]    .* 1000,\n           [ 5291.613719530499, -2354.5417593130833, -4175.561367156414]  .* 1000,\n           [-2416.3705905186903, -268.74923235392623, -6715.411357310478] .* 1000,\n           [-6795.043410709359, 2184.4414321930635, -0.4327055325971031]  .* 1000,\n       ];\n\njulia> vv_i = [\n           [0.3445760107690598, 1.0395135806993514, 7.393686131436984]    .* 1000,\n           [6.875680282038698, -1.864319399615942, 2.270603214569518]     .* 1000,\n           [3.8964090757666496, -2.1887896252945875, -5.9960180359219075] .* 1000,\n           [-4.470258022565413, 0.5119576359985208, -5.9608372367141635]  .* 1000,\n           [-6.647358060413909, 2.495415251255861, 2.292118747543002]     .* 1000,\n           [0.3427096905434428, 1.040125572862349, 7.3936887585116855]    .* 1000,\n       ];\n\njulia> vjd = [\n           2.46002818657856e6\n           2.460028200467449e6\n           2.460028214356338e6\n           2.4600282282452267e6\n           2.4600282421341157e6\n           2.4600282560230047e6\n       ];\n\njulia> orb, P = fit_j4_mean_elements(vjd, vr_i, vv_i)\nACTION:   Fitting the mean elements for the J4 propagator.\n           Iteration        Position RMSE        Velocity RMSE           Total RMSE       RMSE Variation\n                                     [km]             [km / s]                  [ ]\nPROGRESS:         23              4.33863           0.00539962              4338.63         -2.90777e-06 %\n\n(KeplerianElements{Float64, Float64}: Epoch = 2.46003e6 (2023-03-24T18:08:40.388), [0.16604866262321472 0.06643593039980161 … -3.8553206984036995e-5 0.00012403204426258087; 0.06643593040175688 0.26633435614867085 … -1.7942563356579497e-5 -1.95681107792859e-5; … ; -3.855320698470177e-5 -1.794256335557519e-5 … 4.3972013198895673e-7 -8.092682623169118e-8; 0.000124032044261828 -1.9568110780915995e-5 … -8.092682623078798e-8 1.2451901466558624e-7])\n\njulia> orb\nKeplerianElements{Float64, Float64}:\n           Epoch :    2.46003e6 (2023-03-24T18:08:40.388)\n Semi-major axis : 7131.64       km\n    Eccentricity :    0.00114298\n     Inclination :   98.4366     °\n            RAAN :  162.177      °\n Arg. of Perigee :  101.282      °\n    True Anomaly :  258.693      °\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.fit_j4osc_mean_elements!-Union{Tuple{Tv}, Tuple{Tjd}, Tuple{Tepoch}, Tuple{T}, Tuple{J4OsculatingPropagator{Tepoch, T}, AbstractVector{Tjd}, AbstractVector{Tv}, AbstractVector{Tv}}} where {T<:Number, Tepoch<:Number, Tjd<:Number, Tv<:(AbstractVector)}","page":"Library","title":"SatelliteToolboxPropagators.fit_j4osc_mean_elements!","text":"fit_j4osc_mean_elements!(j4oscd::J4OsculatingPropagator{Tepoch, T}, vjd::AbstractVector{Tjd}, vr_i::AbstractVector{Tv}, vv_i::AbstractVector{Tv}; kwargs...) where {T<:Number, Tepoch<:Number, Tjd<:Number, Tv<:AbstractVector} -> KeplerianElements{Tepoch, T}, SMatrix{6, 6, T}\n\nFit a set of mean Keplerian elements for the J4 osculating orbit propagator j4oscd using the osculating elements represented by a set of position vectors vr_i [m] and a set of velocity vectors vv_i [m / s] represented in an inertial reference frame at instants in the array vjd [Julian Day].\n\nnote: Note\nThe J4 osculating orbit propagator j4oscd will be initialized with the Keplerian elements returned by the function.\n\nKeywords\n\natol::Number: Tolerance for the residue absolute value. If the residue is lower than   atol at any iteration, the computation loop stops.   (Default = 2e-4)\nrtol::Number: Tolerance for the relative difference between the residues. If the   relative difference between the residues in two consecutive iterations is lower than   rtol, the computation loop stops.   (Default = 2e-4)\ninitial_guess::Union{Nothing, KeplerianElements}: Initial guess for the mean elements   fitting process. If it is nothing, the algorithm will obtain an initial estimate from   the osculating elements in vr_i and vv_i.   (Default = nothing)\njacobian_perturbation::Number: Initial state perturbation to compute the   finite-difference when calculating the Jacobian matrix.   (Default = 1e-3)\njacobian_perturbation_tol::Number: Tolerance to accept the perturbation when calculating   the Jacobian matrix. If the computed perturbation is lower than   jacobian_perturbation_tol, we increase it until it absolute value is higher than   jacobian_perturbation_tol.   (Default = 1e-7)\nmax_iterations::Int: Maximum number of iterations allowed for the least-square fitting.   (Default = 50)\nmean_elements_epoch::Number: Epoch for the fitted mean elements.   (Default = vjd[end])\nverbose::Bool: If true, the algorithm prints debugging information to stdout.   (Default = true)\nweight_vector::AbstractVector: Vector with the measurements weights for the least-square   algorithm. We assemble the weight matrix W as a diagonal matrix with the elements in   weight_vector at its diagonal.   (Default = @SVector(ones(Bool, 6)))\n\nReturns\n\nKeplerianElements{Tepoch, T}: Fitted Keplerian elements.\nSMatrix{6, 6, T}: Final covariance matrix of the least-square algorithm.\n\nExamples\n\n# Allocate a new J4 osculating orbit propagator using a dummy Keplerian elements.\njulia> j4oscd = j4osc_init(KeplerianElements{Float64, Float64}(0, 7000e3, 0, 0, 0, 0, 0));\n\njulia> vr_i = [\n           [-6792.402703741442, 2192.6458461287293, 0.18851758695295118] .* 1000,\n           [-6357.88873265975, 2391.9476768911686, 2181.838771262736] .* 1000\n       ];\n\njulia> vv_i = [\n           [0.3445760107690598, 1.0395135806993514, 7.393686131436984] .* 1000,\n           [2.5285015912807003, 0.27812476784300005, 7.030323100703928] .* 1000\n       ];\n\njulia> vjd = [\n           2.46002818657856e6,\n           2.460028190050782e6\n       ];\n\njulia> orb, P = fit_j4osc_mean_elements!(j4oscd, vjd, vr_i, vv_i)\nACTION:   Fitting the mean elements for the J4 osculating propagator.\n           Iteration        Position RMSE        Velocity RMSE           Total RMSE       RMSE Variation\n                                     [km]             [km / s]                  [ ]\nPROGRESS:          4          1.68852e-05           0.00259716              2.59722          6.52143e-10 %\n\n(KeplerianElements{Float64, Float64}: Epoch = 2.46003e6 (2023-03-24T16:33:40.388), [0.999942775712293 -0.004901178682591695 … -0.00012021347649120565 -0.0001155014732440418; -0.004901178674245216 1.0007325984965127 … 0.0032661543862499806 3.8581997167487534e-5; … ; -0.00012021347646254671 0.003266154386250846 … 2.204822797002821e-5 5.3982040158043245e-8; -0.00011550147323899825 3.8581997169916946e-5 … 5.398204016417114e-8 2.1657607378172235e-5])\n\njulia> orb\nKeplerianElements{Float64, Float64}:\n           Epoch :    2.46003e6 (2023-03-24T16:33:40.388)\n Semi-major axis : 7135.79       km\n    Eccentricity :    0.00135314\n     Inclination :   98.4304     °\n            RAAN :  162.113      °\n Arg. of Perigee :   64.9687     °\n    True Anomaly :  313.042      °\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.fit_j4osc_mean_elements-Union{Tuple{Tv}, Tuple{Tjd}, Tuple{AbstractVector{Tjd}, AbstractVector{Tv}, AbstractVector{Tv}}} where {Tjd<:Number, Tv<:(AbstractVector)}","page":"Library","title":"SatelliteToolboxPropagators.fit_j4osc_mean_elements","text":"fit_j4osc_mean_elements(vjd::AbstractVector{Tjd}, vr_i::AbstractVector{Tv}, vv_i::AbstractVector{Tv}; kwargs...) where {Tjd<:Number, Tv<:AbstractVector} -> KeplerianElements{Float64, Float64}, SMatrix{6, 6, Float64}\n\nFit a set of mean Keplerian elements for the J4 osculating orbit propagator using the osculating elements represented by a set of position vectors vr_i [m] and a set of velocity vectors vv_i [m / s] represented in an inertial reference frame at instants in the array vjd [Julian Day].\n\nnote: Note\nThis algorithm version will allocate a new J4 osculating propagator with the default constants j4c_egm2008. If another set of constants are required, use the function fit_j4osc_mean_elements! instead.\n\nKeywords\n\natol::Number: Tolerance for the residue absolute value. If the residue is lower than   atol at any iteration, the computation loop stops.   (Default = 2e-4)\nrtol::Number: Tolerance for the relative difference between the residues. If the   relative difference between the residues in two consecutive iterations is lower than   rtol, the computation loop stops.   (Default = 2e-4)\ninitial_guess::Union{Nothing, KeplerianElements}: Initial guess for the mean elements   fitting process. If it is nothing, the algorithm will obtain an initial estimate from   the osculating elements in vr_i and vv_i.   (Default = nothing)\njacobian_perturbation::Number: Initial state perturbation to compute the   finite-difference when calculating the Jacobian matrix.   (Default = 1e-3)\njacobian_perturbation_tol::Number: Tolerance to accept the perturbation when calculating   the Jacobian matrix. If the computed perturbation is lower than   jacobian_perturbation_tol, we increase it until it absolute value is higher than   jacobian_perturbation_tol.   (Default = 1e-7)\nmax_iterations::Int: Maximum number of iterations allowed for the least-square fitting.   (Default = 50)\nmean_elements_epoch::Number: Epoch for the fitted mean elements.   (Default = vjd[end])\nverbose::Bool: If true, the algorithm prints debugging information to stdout.   (Default = true)\nweight_vector::AbstractVector: Vector with the measurements weights for the least-square   algorithm. We assemble the weight matrix W as a diagonal matrix with the elements in   weight_vector at its diagonal.   (Default = @SVector(ones(Bool, 6)))\n\nReturns\n\nKeplerianElements{Float64, Float64}: Fitted Keplerian elements.\nSMatrix{6, 6, Float64}: Final covariance matrix of the least-square algorithm.\n\nExamples\n\njulia> vr_i = [\n           [-6792.402703741442, 2192.6458461287293, 0.18851758695295118] .* 1000,\n           [-6357.88873265975, 2391.9476768911686, 2181.838771262736] .* 1000\n       ];\n\njulia> vv_i = [\n           [0.3445760107690598, 1.0395135806993514, 7.393686131436984] .* 1000,\n           [2.5285015912807003, 0.27812476784300005, 7.030323100703928] .* 1000\n       ];\n\njulia> vjd = [\n           2.46002818657856e6,\n           2.460028190050782e6\n       ];\n\njulia> orb, P = fit_j4osc_mean_elements(vjd, vr_i, vv_i)\nACTION:   Fitting the mean elements for the J4 osculating propagator.\n           Iteration        Position RMSE        Velocity RMSE           Total RMSE       RMSE Variation\n                                     [km]             [km / s]                  [ ]\nPROGRESS:          4          1.68852e-05           0.00259716              2.59722          6.52143e-10 %\n\n(KeplerianElements{Float64, Float64}: Epoch = 2.46003e6 (2023-03-24T16:33:40.388), [0.999942775712293 -0.004901178682591695 … -0.00012021347649120565 -0.0001155014732440418; -0.004901178674245216 1.0007325984965127 … 0.0032661543862499806 3.8581997167487534e-5; … ; -0.00012021347646254671 0.003266154386250846 … 2.204822797002821e-5 5.3982040158043245e-8; -0.00011550147323899825 3.8581997169916946e-5 … 5.398204016417114e-8 2.1657607378172235e-5])\n\njulia> orb\nKeplerianElements{Float64, Float64}:\n           Epoch :    2.46003e6 (2023-03-24T16:33:40.388)\n Semi-major axis : 7135.79       km\n    Eccentricity :    0.00135314\n     Inclination :   98.4304     °\n            RAAN :  162.113      °\n Arg. of Perigee :   64.9687     °\n    True Anomaly :  313.042      °\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.j2!-Union{Tuple{T}, Tuple{Tepoch}, Tuple{J2Propagator{Tepoch, T}, Number}} where {Tepoch<:Number, T<:Number}","page":"Library","title":"SatelliteToolboxPropagators.j2!","text":"j2!(j2d::J2Propagator{Tepoch, T}, t::Number) where {Tepoch, T} -> SVector{3, T}, SVector{3, T}\n\nPropagate the orbit defined in j2d (see J2Propagator) to t [s] after the epoch of the input mean elements in j2d.\n\nnote: Note\nThe internal values in j2d will be modified.\n\nReturns\n\nSVector{3, T}: Position vector [m] represented in the inertial frame at propagation   instant.\nSVector{3, T}: Velocity vector [m / s] represented in the inertial frame at propagation   instant.\n\nRemarks\n\nThe inertial frame in which the output is represented depends on which frame it was used to generate the orbit parameters. Notice that the perturbation theory requires an inertial frame with true equator.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.j2-Tuple{Number, KeplerianElements}","page":"Library","title":"SatelliteToolboxPropagators.j2","text":"j2(Δt::Number, orb₀::KeplerianElements; kwargs...) -> SVector{3, T}, SVector{3, T}, J2Propagator\n\nInitialize the J2 propagator structure using the input elements orb₀ [SI units] and propagate the orbit until the time Δt [s].\n\nnote: Note\nThe type used in the propagation will be the same as used to define the constants in the structure j2c.\n\nKeywords\n\nj2c::J2PropagatorConstants: J2 orbit propagator constants (see   J2PropagatorConstants).   (Default = j2c_egm2008)\n\nReturns\n\nSVector{3, T}: Position vector [m] represented in the inertial frame at propagation   instant.\nSVector{3, T}: Velocity vector [m / s] represented in the inertial frame at propagation   instant.\nJ2Propagator: Structure with the initialized parameters.\n\nRemarks\n\nThe inertial frame in which the output is represented depends on which frame it was used to generate the orbit parameters. Notice that the perturbation theory requires an inertial frame with true equator.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.j2_init!-Union{Tuple{T}, Tuple{Tepoch}, Tuple{J2Propagator{Tepoch, T}, KeplerianElements}} where {Tepoch<:Number, T<:Number}","page":"Library","title":"SatelliteToolboxPropagators.j2_init!","text":"j2_init!(j2d::J2Propagator, orb₀::KeplerianElements) -> Nothing\n\nInitialize the J2 orbit propagator structure j2d using the mean Keplerian elements orb₀ [SI units].\n\nwarning: Warning\nThe propagation constants j2c::J2PropagatorConstants in j2d will not be changed. Hence, they must be initialized.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.j2_init-Union{Tuple{KeplerianElements{Tepoch, Tkepler}}, Tuple{T}, Tuple{Tkepler}, Tuple{Tepoch}} where {Tepoch<:Number, Tkepler<:Number, T<:Number}","page":"Library","title":"SatelliteToolboxPropagators.j2_init","text":"j2_init(orb₀::KeplerianElements; kwargs...) -> J2Propagator\n\nCreate and initialize the J2 orbit propagator structure using the mean Keplerian elements orb₀ [SI units].\n\nnote: Note\nThe type used in the propagation will be the same as used to define the constants in the structure j2c.\n\nKeywords\n\nj2c::J2PropagatorConstants: J2 orbit propagator constants (see   J2PropagatorConstants).   (Default = j2c_egm2008)\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.j2osc!-Union{Tuple{T}, Tuple{Tepoch}, Tuple{J2OsculatingPropagator{Tepoch, T}, Number}} where {Tepoch<:Number, T<:Number}","page":"Library","title":"SatelliteToolboxPropagators.j2osc!","text":"j2osc!(j2oscd::J2OsculatingPropagator{Tepoch, T}, t::Number) where {Tepoch, T} -> SVector{3, T}, SVector{3, T}\n\nPropagate the orbit defined in j2oscd (see J2OsculatingPropagator) to t [s] after the epoch of the input mean elements in j2d.\n\nnote: Note\nThe internal values in j2oscd will be modified.\n\nReturns\n\nSVector{3, T}: Position vector [m] represented in the inertial frame at propagation   instant.\nSVector{3, T}: Velocity vector [m / s] represented in the inertial frame at propagation   instant.\n\nRemarks\n\nThe inertial frame in which the output is represented depends on which frame it was used to generate the orbit parameters. Notice that the perturbation theory requires an inertial frame with true equator.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.j2osc-Tuple{Number, KeplerianElements}","page":"Library","title":"SatelliteToolboxPropagators.j2osc","text":"j2osc(Δt::Number, orb₀::KeplerianElements; kwargs...) -> SVector{3, T}, SVector{3, T}, J2OsculatingPropagator\n\nInitialize the J2 osculating propagator structure using the input elements orb₀ [SI units] and propagate the orbit until the time Δt [s].\n\nnote: Note\nThe type used in the propagation will be the same as used to define the constants in the structure j2c.\n\nKeywords\n\nj2c::J2PropagatorConstants{T}: J2 orbit propagator constants (see   J2PropagatorConstants).   (Default = j2c_egm2008)\n\nReturns\n\nSVector{3, T}: Position vector [m] represented in the inertial frame at propagation   instant.\nSVector{3, T}: Velocity vector [m / s] represented in the inertial frame at propagation   instant.\nJ2OsculatingPropagator: Structure with the initialized parameters.\n\nRemarks\n\nThe inertial frame in which the output is represented depends on which frame it was used to generate the orbit parameters. Notice that the perturbation theory requires an inertial frame with true equator.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.j2osc_init!-Tuple{J2OsculatingPropagator, KeplerianElements}","page":"Library","title":"SatelliteToolboxPropagators.j2osc_init!","text":"j2osc_init!(j2oscd::J2OsculatingPropagator, orb₀::KeplerianElements) -> Nothing\n\nInitialize the J2 osculating orbit propagator structure j2oscd using the mean Keplerian elements orb₀ [SI units].\n\nwarning: Warning\nThe propagation constants j2c::J2PropagatorConstants in j2oscd.j2d will not be changed. Hence, they must be initialized.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.j2osc_init-Union{Tuple{KeplerianElements{Tepoch, Tkepler}}, Tuple{T}, Tuple{Tkepler}, Tuple{Tepoch}} where {Tepoch<:Number, Tkepler<:Number, T<:Number}","page":"Library","title":"SatelliteToolboxPropagators.j2osc_init","text":"j2osc_init(orb₀::KeplerianElements; kwargs...) -> J2OsculatingPropagator\n\nCreate and initialize the J2 osculating orbit propagator structure using the mean Keplerian elements orb₀ [SI units].\n\nnote: Note\nThe type used in the propagation will be the same as used to define the constants in the structure j2c.\n\nKeywords\n\nj2c::J2PropagatorConstants: J2 orbit propagator constants (see   J2PropagatorConstants).   (Default = j2c_egm2008)\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.j4!-Union{Tuple{T}, Tuple{Tepoch}, Tuple{J4Propagator{Tepoch, T}, Number}} where {Tepoch<:Number, T<:Number}","page":"Library","title":"SatelliteToolboxPropagators.j4!","text":"j4!(j4d::J4Propagator{Tepoch, T}, t::Number) where {Tepoch<:Number, T<:Number} -> SVector{3, T}, SVector{3, T}\n\nPropagate the orbit defined in j4d (see J4Propagator) to t [s] after the epoch of the input mean elements in j4d.\n\nnote: Note\nThe internal values in j4d will be modified.\n\nReturns\n\nSVector{3, T}: Position vector [m] represented in the inertial frame at propagation   instant.\nSVector{3, T}: Velocity vector [m / s] represented in the inertial frame at propagation   instant.\n\nRemarks\n\nThe inertial frame in which the output is represented depends on which frame it was used to generate the orbit parameters. Notice that the perturbation theory requires an inertial frame with true equator.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.j4-Tuple{Number, KeplerianElements}","page":"Library","title":"SatelliteToolboxPropagators.j4","text":"j4(Δt::Number, orb₀::KeplerianElements; kwargs...) -> SVector{3, T}, SVector{3, T}, J4Propagator\n\nInitialize the J4 propagator structure using the input elements orb₀ and propagate the orbit until the time Δt [s].\n\nnote: Note\nThe type used in the propagation will be the same as used to define the constants in the structure j4c.\n\nKeywords\n\nj4c::J4PropagatorConstants: J4 orbit propagator constants (see   J4PropagatorConstants).   (Default = j4c_egm2008)\n\nReturns\n\nSVector{3, T}: Position vector [m] represented in the inertial frame at propagation   instant.\nSVector{3, T}: Velocity vector [m / s] represented in the inertial frame at propagation   instant.\nJ4Propagator: Structure with the initialized parameters.\n\nRemarks\n\nThe inertial frame in which the output is represented depends on which frame it was used to generate the orbit parameters. Notice that the perturbation theory requires an inertial frame with true equator.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.j4_init!-Union{Tuple{T}, Tuple{Tepoch}, Tuple{J4Propagator{Tepoch, T}, KeplerianElements}} where {Tepoch<:Number, T<:Number}","page":"Library","title":"SatelliteToolboxPropagators.j4_init!","text":"j4_init!(j4d::J4Propagator, orb₀::KeplerianElements) -> Nothing\n\nInitialize the J4 orbit propagator structure j4d using the mean Keplerian elements orb₀.\n\nwarning: Warning\nThe propagation constants j4c::J4PropagatorConstants in j4d will not be changed. Hence, they must be initialized.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.j4_init-Union{Tuple{KeplerianElements{Tepoch, Tkepler}}, Tuple{T}, Tuple{Tkepler}, Tuple{Tepoch}} where {Tepoch<:Number, Tkepler<:Number, T<:Number}","page":"Library","title":"SatelliteToolboxPropagators.j4_init","text":"j4_init(orb₀::KeplerianElements; kwargs...) -> J4Propagator\n\nCreate and initialize the J4 orbit propagator structure using the mean Keplerian elements orb₀.\n\nnote: Note\nThe type used in the propagation will be the same as used to define the constants in the structure j4c.\n\nKeywords\n\nj4c::J4PropagatorConstants: J4 orbit propagator constants (see   J4PropagatorConstants).   (Default = j4c_egm2008)\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.j4osc!-Union{Tuple{T}, Tuple{Tepoch}, Tuple{J4OsculatingPropagator{Tepoch, T}, Number}} where {Tepoch<:Number, T<:Number}","page":"Library","title":"SatelliteToolboxPropagators.j4osc!","text":"j4osc!(j4oscd::J4OsculatingPropagator{Tepoch, T}, t::Number) where {Tepoch, T} -> SVector{3, T}, SVector{3, T}\n\nPropagate the orbit defined in j4oscd (see J4OsculatingPropagator) to t [s] after the epoch of the input mean elements in j4d.\n\nnote: Note\nThe internal values in j4oscd will be modified.\n\nReturns\n\nSVector{3, T}: Position vector [m] represented in the inertial frame at propagation   instant.\nSVector{3, T}: Velocity vector [m / s] represented in the inertial frame at propagation   instant.\n\nRemarks\n\nThe inertial frame in which the output is represented depends on which frame it was used to generate the orbit parameters. Notice that the perturbation theory requires an inertial frame with true equator.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.j4osc-Tuple{Number, KeplerianElements}","page":"Library","title":"SatelliteToolboxPropagators.j4osc","text":"j4osc(Δt::Number, orb₀::KeplerianElements; kwargs...) -> SVector{3, T}, SVector{3, T}, J4OsculatingPropagator\n\nInitialize the J4 osculating propagator structure using the input elements orb₀ and propagate the orbit until the time Δt [s].\n\nnote: Note\nThe type used in the propagation will be the same as used to define the constants in the structure j4c.\n\nKeywords\n\nj4c::J4PropagatorConstants{T}: J4 orbit propagator constants (see J4PropagatorConstants). (Default = j4c_egm2008)\n\nReturns\n\nSVector{3, T}: Position vector [m] represented in the inertial frame at propagation   instant.\nSVector{3, T}: Velocity vector [m / s] represented in the inertial frame at propagation   instant.\nJ4OsculatingPropagator: Structure with the initialized parameters.\n\nRemarks\n\nThe inertial frame in which the output is represented depends on which frame it was used to generate the orbit parameters. Notice that the perturbation theory requires an inertial frame with true equator.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.j4osc_init!-Tuple{J4OsculatingPropagator, KeplerianElements}","page":"Library","title":"SatelliteToolboxPropagators.j4osc_init!","text":"j4osc_init!(j4oscd::J4OsculatingPropagator, orb₀::KeplerianElements) -> Nothing\n\nInitialize the J4 osculating orbit propagator structure j4oscd using the mean Keplerian elements orb₀.\n\nwarning: Warning\nThe propagation constants j4c::J4PropagatorConstants in j4oscd.j4d will not be changed. Hence, they must be initialized.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.j4osc_init-Union{Tuple{KeplerianElements{Tepoch, Tkepler}}, Tuple{T}, Tuple{Tkepler}, Tuple{Tepoch}} where {Tepoch<:Number, Tkepler<:Number, T<:Number}","page":"Library","title":"SatelliteToolboxPropagators.j4osc_init","text":"j4osc_init(orb₀::KeplerianElements; kwargs...) -> J4OsculatingPropagator\n\nCreate and initialize the J4 osculating orbit propagator structure using the mean Keplerian elements orb₀.\n\nnote: Note\nThe type used in the propagation will be the same as used to define the constants in the structure j4c.\n\nKeywords\n\nj4c::J4PropagatorConstants: J4 orbit propagator constants (see   J4PropagatorConstants). (Default = j4c_egm2008)\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.twobody!-Union{Tuple{T}, Tuple{Tepoch}, Tuple{TwoBodyPropagator{Tepoch, T}, Number}} where {Tepoch<:Number, T<:Number}","page":"Library","title":"SatelliteToolboxPropagators.twobody!","text":"twobody!(tbd::TwoBodyPropagator{Tepoch, T}, t::Number) where {Tepoch, T} -> SVector{3, T}, SVector{3, T}\n\nPropagate the orbit defined in tbd (see TwoBodyPropagator) to t [s] after the epoch of the input mean elements in tbd.\n\nnote: Note\nThe internal values in tbd will be modified.\n\nReturns\n\nSVector{3, T}: Position vector [m] represented in the inertial frame at propagation   instant.\nSVector{3, T}: Velocity vector [m / s] represented in the inertial frame at propagation   instant.\n\nRemarks\n\nThe inertial frame in which the output is represented depends on which frame it was used to generate the orbit parameters.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.twobody-Union{Tuple{T}, Tuple{Number, KeplerianElements}} where T<:Number","page":"Library","title":"SatelliteToolboxPropagators.twobody","text":"twobody(Δt::Number, orb₀::KeplerianElements; kwargs...) -> SVector{3, T}, SVector{3, T}, TwoBodyPropagator\n\nInitialize the two-body propagator structure using the input elements orb₀ and propagate the orbit until the time Δt [s].\n\nnote: Note\nThe type used in the propagation will be the same as used to define the gravitational constant m0.\n\nKeywords\n\nm0::T: Standard gravitational parameter of the central body [m³ / s²].   (Default = tbc_m0)\n\nReturns\n\nSVector{3, T}: Position vector [m] represented in the inertial frame at propagation   instant.\nSVector{3, T}: Velocity vector [m / s] represented in the inertial frame at propagation   instant.\nTwoBodyPropagator: Structure with the initialized parameters.\n\nRemarks\n\nThe inertial frame in which the output is represented depends on which frame it was used to generate the orbit parameters.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.twobody_init!-Union{Tuple{T}, Tuple{Tepoch}, Tuple{TwoBodyPropagator{Tepoch, T}, KeplerianElements}} where {Tepoch<:Number, T<:Number}","page":"Library","title":"SatelliteToolboxPropagators.twobody_init!","text":"twobody_init!(tbd::TwoBodyPropagator, orb₀::KeplerianElements; kwargs...) -> Nothing\n\nInitialize the two-body propagator structure tbd using the mean Keplerian elements orb₀.\n\nwarning: Warning\nThe propagation constant μ::Number in tbd will not be changed. Hence, it must be initialized.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.twobody_init-Union{Tuple{KeplerianElements{Tepoch, Tkepler}}, Tuple{T}, Tuple{Tkepler}, Tuple{Tepoch}} where {Tepoch<:Number, Tkepler<:Number, T<:Number}","page":"Library","title":"SatelliteToolboxPropagators.twobody_init","text":"twobody_init(orb₀::KeplerianElements; kwargs...) -> TwoBodyPropagator\n\nCreate and initialize the two-body propagator structure using the mean Keplerian elements orb₀.\n\nnote: Note\nThe type used in the propagation will be the same as used to define the gravitational constant m0.\n\nKeywords\n\nm0::T: Standard gravitational parameter of the central body [m³ / s²].   (Default = tbc_m0)\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.update_j2_mean_elements_epoch!-Tuple{J2Propagator, KeplerianElements, Dates.DateTime}","page":"Library","title":"SatelliteToolboxPropagators.update_j2_mean_elements_epoch!","text":"update_j2_mean_elements_epoch!(j2d::J2Propagator, orb::KeplerianElements, new_epoch::Union{Number, DateTime}) -> KepleriranElements\n\nUpdate the epoch of the mean elements orb using the propagator j2d to new_epoch, which can be represented by a Julian Day or a DateTime.\n\nnote: Note\nThe J2 orbit propagator j2d will be initialized with the Keplerian elements returned by the function.\n\nExamples\n\njulia> orb = KeplerianElements(\n           DateTime(\"2023-01-01\") |> datetime2julian,\n           7190.982e3,\n           0.001111,\n           98.405 |> deg2rad,\n           90     |> deg2rad,\n           200    |> deg2rad,\n           45     |> deg2rad\n       )\nKeplerianElements{Float64, Float64}:\n           Epoch :    2.45995e6 (2023-01-01T00:00:00)\n Semi-major axis : 7190.98     km\n    Eccentricity :    0.001111\n     Inclination :   98.405    °\n            RAAN :   90.0      °\n Arg. of Perigee :  200.0      °\n    True Anomaly :   45.0      °\n\n# Allocate a new J2 orbit propagator using the created Keplerian elements. Notice that any\n# set of Keplerian elements can be used here.\njulia> j2d = j2_init(orb);\n\njulia> update_j2_mean_elements_epoch!(j2d, orb, DateTime(\"2023-01-02\"))\nKeplerianElements{Float64, Float64}:\n           Epoch :    2.45995e6 (2023-01-02T00:00:00)\n Semi-major axis : 7190.98     km\n    Eccentricity :    0.001111\n     Inclination :   98.405    °\n            RAAN :   90.9565   °\n Arg. of Perigee :  197.078    °\n    True Anomaly :  127.291    °\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.update_j2_mean_elements_epoch-Union{Tuple{Tepoch}, Tuple{T}, Tuple{KeplerianElements{Tepoch, T}, Union{Dates.DateTime, Number}}} where {T<:Number, Tepoch<:Number}","page":"Library","title":"SatelliteToolboxPropagators.update_j2_mean_elements_epoch","text":"update_j2_mean_elements_epoch(orb::KeplerianElements, new_epoch::Union{Number, DateTime}) -> KepleriranElements\n\nUpdate the epoch of the mean elements orb using a J2 orbit propagator to new_epoch, which can be represented by a Julian Day or a DateTime.\n\nnote: Note\nThis algorithm version will allocate a new J2 propagator with the default constants j2c_egm2008. If another set of constants are required, use the function update_j2osc_mean_elements_epoch! instead.\n\nExamples\n\njulia> orb = KeplerianElements(\n           DateTime(\"2023-01-01\") |> datetime2julian,\n           7190.982e3,\n           0.001111,\n           98.405 |> deg2rad,\n           90     |> deg2rad,\n           200    |> deg2rad,\n           45     |> deg2rad\n       )\nKeplerianElements{Float64, Float64}:\n           Epoch :    2.45995e6 (2023-01-01T00:00:00)\n Semi-major axis : 7190.98     km\n    Eccentricity :    0.001111\n     Inclination :   98.405    °\n            RAAN :   90.0      °\n Arg. of Perigee :  200.0      °\n    True Anomaly :   45.0      °\n\njulia> update_j2_mean_elements_epoch(orb, DateTime(\"2023-01-02\"))\nKeplerianElements{Float64, Float64}:\n           Epoch :    2.45995e6 (2023-01-02T00:00:00)\n Semi-major axis : 7190.98     km\n    Eccentricity :    0.001111\n     Inclination :   98.405    °\n            RAAN :   90.9565   °\n Arg. of Perigee :  197.078    °\n    True Anomaly :  127.291    °\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.update_j2osc_mean_elements_epoch!-Tuple{J2OsculatingPropagator, KeplerianElements, Dates.DateTime}","page":"Library","title":"SatelliteToolboxPropagators.update_j2osc_mean_elements_epoch!","text":"update_j2osc_mean_elements_epoch!(j2oscd::J2OsculatingPropagator, orb::KeplerianElements, new_epoch::Union{Number, DateTime}) -> KepleriranElements\n\nUpdate the epoch of the mean elements orb using the propagator j2oscd to new_epoch, which can be represented by a Julian Day or a DateTime.\n\nnote: Note\nThe J2 osculating orbit propagator j2oscd will be initialized with the Keplerian elements returned by the function.\n\nExamples\n\njulia> orb = KeplerianElements(\n           DateTime(\"2023-01-01\") |> datetime2julian,\n           7190.982e3,\n           0.001111,\n           98.405 |> deg2rad,\n           90     |> deg2rad,\n           200    |> deg2rad,\n           45     |> deg2rad\n       )\nKeplerianElements{Float64, Float64}:\n           Epoch :    2.45995e6 (2023-01-01T00:00:00)\n Semi-major axis : 7190.98     km\n    Eccentricity :    0.001111\n     Inclination :   98.405    °\n            RAAN :   90.0      °\n Arg. of Perigee :  200.0      °\n    True Anomaly :   45.0      °\n\n# Allocate a new J2 osculating orbit propagator using the created Keplerian elements. Notice\n# that any set of Keplerian elements can be used here.\njulia> j2oscd = j2osc_init(orb);\n\njulia> update_j2osc_mean_elements_epoch!(j2oscd, orb, DateTime(\"2023-01-02\"))\nKeplerianElements{Float64, Float64}:\n           Epoch :    2.45995e6 (2023-01-02T00:00:00)\n Semi-major axis : 7190.98     km\n    Eccentricity :    0.001111\n     Inclination :   98.405    °\n            RAAN :   90.9565   °\n Arg. of Perigee :  197.078    °\n    True Anomaly :  127.291    °\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.update_j2osc_mean_elements_epoch-Union{Tuple{Tepoch}, Tuple{T}, Tuple{KeplerianElements{Tepoch, T}, Union{Dates.DateTime, Number}}} where {T<:Number, Tepoch<:Number}","page":"Library","title":"SatelliteToolboxPropagators.update_j2osc_mean_elements_epoch","text":"update_j2osc_mean_elements_epoch(orb::KeplerianElements, new_epoch::Union{Number, DateTime}) -> KepleriranElements\n\nUpdate the epoch of the mean elements orb using a J2 osculating orbit propagator to new_epoch, which can be represented by a Julian Day or a DateTime.\n\nnote: Note\nThis algorithm version will allocate a new J2 osculating propagator with the default constants j2c_egm2008. If another set of constants are required, use the function update_j2osc_mean_elements_epoch! instead.\n\nExamples\n\njulia> orb = KeplerianElements(\n           DateTime(\"2023-01-01\") |> datetime2julian,\n           7190.982e3,\n           0.001111,\n           98.405 |> deg2rad,\n           90     |> deg2rad,\n           200    |> deg2rad,\n           45     |> deg2rad\n       )\nKeplerianElements{Float64, Float64}:\n           Epoch :    2.45995e6 (2023-01-01T00:00:00)\n Semi-major axis : 7190.98     km\n    Eccentricity :    0.001111\n     Inclination :   98.405    °\n            RAAN :   90.0      °\n Arg. of Perigee :  200.0      °\n    True Anomaly :   45.0      °\n\njulia> update_j2osc_mean_elements_epoch(orb, DateTime(\"2023-01-02\"))\nKeplerianElements{Float64, Float64}:\n           Epoch :    2.45995e6 (2023-01-02T00:00:00)\n Semi-major axis : 7190.98     km\n    Eccentricity :    0.001111\n     Inclination :   98.405    °\n            RAAN :   90.9565   °\n Arg. of Perigee :  197.078    °\n    True Anomaly :  127.291    °\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.update_j4_mean_elements_epoch!-Tuple{J4Propagator, KeplerianElements, Dates.DateTime}","page":"Library","title":"SatelliteToolboxPropagators.update_j4_mean_elements_epoch!","text":"update_j4_mean_elements_epoch!(j4d::J4Propagator, orb::KeplerianElements, new_epoch::Union{Number, DateTime}) -> KepleriranElements\n\nUpdate the epoch of the mean elements orb using the propagator j4d to new_epoch, which can be represented by a Julian Day or a DateTime.\n\nnote: Note\nThe J4 orbit propagator j4d will be initialized with the Keplerian elements returned by the function.\n\nExamples\n\njulia> orb = KeplerianElements(\n           DateTime(\"2023-01-01\") |> datetime2julian,\n           7190.982e3,\n           0.001111,\n           98.405 |> deg2rad,\n           90     |> deg2rad,\n           200    |> deg2rad,\n           45     |> deg2rad\n       )\nKeplerianElements{Float64, Float64}:\n           Epoch :    2.45995e6 (2023-01-01T00:00:00)\n Semi-major axis : 7190.98     km\n    Eccentricity :    0.001111\n     Inclination :   98.405    °\n            RAAN :   90.0      °\n Arg. of Perigee :  200.0      °\n    True Anomaly :   45.0      °\n\n# Allocate a new J4 orbit propagator using the created Keplerian elements. Notice that any\n# set of Keplerian elements can be used here.\njulia> j4d = j4_init(orb);\n\njulia> update_j4_mean_elements_epoch!(j4d, orb, DateTime(\"2023-01-02\"))\nKeplerianElements{Float64, Float64}:\n           Epoch :    2.45995e6 (2023-01-02T00:00:00)\n Semi-major axis : 7190.98     km\n    Eccentricity :    0.001111\n     Inclination :   98.405    °\n            RAAN :   90.9555   °\n Arg. of Perigee :  197.079    °\n    True Anomaly :  127.293    °\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.update_j4_mean_elements_epoch-Union{Tuple{Tepoch}, Tuple{T}, Tuple{KeplerianElements{Tepoch, T}, Union{Dates.DateTime, Number}}} where {T<:Number, Tepoch<:Number}","page":"Library","title":"SatelliteToolboxPropagators.update_j4_mean_elements_epoch","text":"update_j4_mean_elements_epoch(orb::KeplerianElements, new_epoch::Union{Number, DateTime}) -> KepleriranElements\n\nUpdate the epoch of the mean elements orb using a J4 orbit propagator to new_epoch, which can be represented by a Julian Day or a DateTime.\n\nnote: Note\nThis algorithm version will allocate a new J4 propagator with the default constants j4c_egm2008. If another set of constants are required, use the function update_j4osc_mean_elements_epoch! instead.\n\nExamples\n\njulia> orb = KeplerianElements(\n           DateTime(\"2023-01-01\") |> datetime2julian,\n           7190.982e3,\n           0.001111,\n           98.405 |> deg2rad,\n           90     |> deg2rad,\n           200    |> deg2rad,\n           45     |> deg2rad\n       )\nKeplerianElements{Float64, Float64}:\n           Epoch :    2.45995e6 (2023-01-01T00:00:00)\n Semi-major axis : 7190.98     km\n    Eccentricity :    0.001111\n     Inclination :   98.405    °\n            RAAN :   90.0      °\n Arg. of Perigee :  200.0      °\n    True Anomaly :   45.0      °\n\njulia> update_j4_mean_elements_epoch(orb, DateTime(\"2023-01-02\"))\nKeplerianElements{Float64, Float64}:\n           Epoch :    2.45995e6 (2023-01-02T00:00:00)\n Semi-major axis : 7190.98     km\n    Eccentricity :    0.001111\n     Inclination :   98.405    °\n            RAAN :   90.9555   °\n Arg. of Perigee :  197.079    °\n    True Anomaly :  127.293    °\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.update_j4osc_mean_elements_epoch!-Tuple{J4OsculatingPropagator, KeplerianElements, Dates.DateTime}","page":"Library","title":"SatelliteToolboxPropagators.update_j4osc_mean_elements_epoch!","text":"update_j4osc_mean_elements_epoch!(j4oscd::J4OsculatingPropagator, orb::KeplerianElements, new_epoch::Union{Number, DateTime}) -> KepleriranElements\n\nUpdate the epoch of the mean elements orb using the propagator j4oscd to new_epoch, which can be represented by a Julian Day or a DateTime.\n\nnote: Note\nThe J4 osculating orbit propagator j4oscd will be initialized with the Keplerian elements returned by the function.\n\nExamples\n\njulia> orb = KeplerianElements(\n           DateTime(\"2023-01-01\") |> datetime2julian,\n           7190.982e3,\n           0.001111,\n           98.405 |> deg2rad,\n           90     |> deg2rad,\n           200    |> deg2rad,\n           45     |> deg2rad\n       )\nKeplerianElements{Float64, Float64}:\n           Epoch :    2.45995e6 (2023-01-01T00:00:00)\n Semi-major axis : 7190.98     km\n    Eccentricity :    0.001111\n     Inclination :   98.405    °\n            RAAN :   90.0      °\n Arg. of Perigee :  200.0      °\n    True Anomaly :   45.0      °\n\n# Allocate a new J4 osculating orbit propagator using the created Keplerian elements. Notice\n# that any set of Keplerian elements can be used here.\njulia> j4oscd = j4osc_init(orb);\n\njulia> update_j4osc_mean_elements_epoch!(j4oscd, orb, DateTime(\"2023-01-02\"))\nKeplerianElements{Float64, Float64}:\n           Epoch :    2.45995e6 (2023-01-02T00:00:00)\n Semi-major axis : 7190.98     km\n    Eccentricity :    0.001111\n     Inclination :   98.405    °\n            RAAN :   90.9555   °\n Arg. of Perigee :  197.079    °\n    True Anomaly :  127.293    °\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.update_j4osc_mean_elements_epoch-Union{Tuple{Tepoch}, Tuple{T}, Tuple{KeplerianElements{Tepoch, T}, Union{Dates.DateTime, Number}}} where {T<:Number, Tepoch<:Number}","page":"Library","title":"SatelliteToolboxPropagators.update_j4osc_mean_elements_epoch","text":"update_j4osc_mean_elements_epoch(orb::KeplerianElements, new_epoch::Union{Number, DateTime}) -> KepleriranElements\n\nUpdate the epoch of the mean elements orb using a J4 osculating orbit propagator to new_epoch, which can be represented by a Julian Day or a DateTime.\n\nnote: Note\nThis algorithm version will allocate a new J4 osculating propagator with the default constants j4c_egm2008. If another set of constants are required, use the function update_j4osc_mean_elements_epoch! instead.\n\nExamples\n\njulia> orb = KeplerianElements(\n           DateTime(\"2023-01-01\") |> datetime2julian,\n           7190.982e3,\n           0.001111,\n           98.405 |> deg2rad,\n           90     |> deg2rad,\n           200    |> deg2rad,\n           45     |> deg2rad\n       )\nKeplerianElements{Float64, Float64}:\n           Epoch :    2.45995e6 (2023-01-01T00:00:00)\n Semi-major axis : 7190.98     km\n    Eccentricity :    0.001111\n     Inclination :   98.405    °\n            RAAN :   90.0      °\n Arg. of Perigee :  200.0      °\n    True Anomaly :   45.0      °\n\njulia> update_j4osc_mean_elements_epoch(orb, DateTime(\"2023-01-02\"))\nKeplerianElements{Float64, Float64}:\n           Epoch :    2.45995e6 (2023-01-02T00:00:00)\n Semi-major axis : 7190.98     km\n    Eccentricity :    0.001111\n     Inclination :   98.405    °\n            RAAN :   90.9555   °\n Arg. of Perigee :  197.079    °\n    True Anomaly :  127.293    °\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.Propagators.OrbitPropagator","page":"Library","title":"SatelliteToolboxPropagators.Propagators.OrbitPropagator","text":"abstract type OrbitPropagator{Tepoch<:Number, T<:Number}\n\nAbstract type for the orbit propagators.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolboxPropagators.Propagators.epoch","page":"Library","title":"SatelliteToolboxPropagators.Propagators.epoch","text":"epoch(orbp::OrbitPropagator{Tepoch, T}) where {Tepoch<:Number, T<:Number} -> Tepoch\n\nReturn the initial elements' epoch of the propagator orbp [JD].\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolboxPropagators.Propagators.fit_mean_elements","page":"Library","title":"SatelliteToolboxPropagators.Propagators.fit_mean_elements","text":"fit_mean_elements(::Val{:propagator}, vjd::AbstractVector{Tjd}, vr_i::AbstractVector{Tv}, vv_i::AbstractVector{Tv}; kwargs...) where {Tjd<:Number, Tv<:AbstractVector} -> <Mean elements>\nfit_mean_elements(::Val{:propagator}, vsv::OrbitStateVector{Tepoch, T}; kwargs...) where {Tepoch<:Number, T<:Number} -> <Mean elements>\n\nFit a set of mean elements for the propagator using the osculating state vector represented in an intertial reference frame. The state vector can be represented using a set of position vectors vr_i [m] and a set of velocity vectors vv_i [m / s] obtained at the instants in the array vjd [Julian Day], or an array of OrbitStateVector vsv [SI], containing the same information. The keywords kwargs depends on the propagator type.\n\nThis function returns the set of mean elements used to initialize the propagator.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolboxPropagators.Propagators.fit_mean_elements!","page":"Library","title":"SatelliteToolboxPropagators.Propagators.fit_mean_elements!","text":"fit_mean_elements!(orbp::OrbitPropagator, vjd::AbstractVector{Tjd}, vr_i::AbstractVector{Tv}, vv_i::AbstractVector{Tv}; kwargs...) where {Tjd<:Number, Tv<:AbstractVector} -> <Mean elements>\nfit_mean_elements!(orbp::OrbitPropagator, vsv::Vector{OrbitStateVector{Tepoch, T}}; kwargs...) where {Tepoch<:Number, T<:Number} -> <Mean elements>\n\nFit a set of mean elements for the propagator orbp using the osculating state vector represented in an intertial reference frame. The state vector can be represented using a set of position vectors vr_i [m] and a set of velocity vectors vv_i [m / s] obtained at the instants in the array vjd [Julian Day], or an array of OrbitStateVector vsv [SI], containing the same information. The keywords kwargs depends on the propagator type.\n\nThis function returns the set of mean elements used to initialize the propagator and also initializes orbp with the fitted mean elements.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolboxPropagators.Propagators.init","page":"Library","title":"SatelliteToolboxPropagators.Propagators.init","text":"init(::Val{:propagator}, args...; kwargs...) -> OrbitPropagator\n\nCreate and initialize the orbit propagator. The arguments args and keywords kwargs depends of the propagator type.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolboxPropagators.Propagators.init!","page":"Library","title":"SatelliteToolboxPropagators.Propagators.init!","text":"init!(orbp::OrbitPropagator, args...; kwargs...) -> Nothing\n\nInitialize the orbit propagator orbp. The arguments args and keywords kwargs depends of the propagator type.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolboxPropagators.Propagators.last_instant","page":"Library","title":"SatelliteToolboxPropagators.Propagators.last_instant","text":"last_instant(orbp::OrbitPropagator{Tepoch, T}) where {Tepoch<:Number, T<:Number} -> T\n\nReturn the last propagation instant [s] measured from the epoch.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolboxPropagators.Propagators.mean_elements-Tuple{OrbitPropagator}","page":"Library","title":"SatelliteToolboxPropagators.Propagators.mean_elements","text":"mean_elements(orbp::OrbitPropagator) -> Union{Nothing, KeplerianElements}\n\nReturn the mean elements using the structure KeplerianElements of the latest propagation performed by orbp. This is an optinal function in the API. It will return nothing if the propagator does not support it.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.Propagators.name-Tuple{OrbitPropagator}","page":"Library","title":"SatelliteToolboxPropagators.Propagators.name","text":"name(orbp::OrbitPropagator) -> String\n\nReturn the name of the orbit propagator orbp. If this function is not defined, the structure name is used: typeof(orbp) |> string.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.Propagators.propagate!","page":"Library","title":"SatelliteToolboxPropagators.Propagators.propagate!","text":"propagate!(orbp::OrbitPropagator{Tepoch, T}, Δt::Number[, sink = Tuple]) where {Tepoch, T} -> SVector{3, T}, SVector{3, T}\npropagate!(orbp::OrbitPropagator{Tepoch, T}, p::Union{Dates.Period, Dates.CompoundPeriod}[, sink = Tuple]) where {Tepoch, T} -> SVector{3, T}, SVector{3, T}\npropagate!(orbp::OrbitPropagator{Tepoch, T}, Δt::Number, sink = OrbitStateVector) where {Tepoch, T} -> OrbitStateVector{Tepoch, T}\npropagate!(orbp::OrbitPropagator{Tepoch, T}, p::Union{Dates.Period, Dates.CompoundPeriod}, sink = OrbitStateVector) where {Tepoch, T} -> OrbitStateVector{Tepoch, T}\n\nPropagate the orbit using orbp by Δt [s] or by the period defined by p from the initial orbit epoch. The output type depends on the parameter sink. If it is omitted, it defaults to Tuple and the output is a tuple with the position and velocity vectors.\n\nReturns\n\nIf sink is Tuple:\n\nSVector{3, T}: Position vector [m] represented in the inertial frame at propagation   instant.\nSVector{3, T}: Velocity vector [m / s] represented in the inertial frame at propagation   instant.\n\nIf sink is OrbitStateVector:\n\nOrbitStateVector{Tepoch, T}: Structure with the orbit state vector [SI] at the   propagation instant.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolboxPropagators.Propagators.propagate!-Union{Tuple{T}, Tuple{OrbitPropagator, AbstractVector{T}}} where T<:Union{Dates.CompoundPeriod, Dates.Period}","page":"Library","title":"SatelliteToolboxPropagators.Propagators.propagate!","text":"propagate!(orbp::OrbitPropagator{Tepoch, T}, vt::AbstractVector[, sink = Tuple]; kwargs...) where {Tepoch <: Number, T <: Number} -> Vector{SVector{3, T}}, Vector{SVector{3, T}}\npropagate!(orbp::OrbitPropagator{Tepoch, T}, vp::AbstractVector{Union{Dates.Period, Dates.CompundPeriod}}[, sink = Tuple]; kwargs...) where {Tepoch <: Number, T <: Number} -> Vector{SVector{3, T}}, Vector{SVector{3, T}}\npropagate!(orbp::OrbitPropagator{Tepoch, T}, vt::AbstractVector, sink = OrbitStateVector; kwargs...) where {Tepoch <: Number, T <: Number} -> Vector{OrbitStateVector{Tepoch, T}}\npropagate!(orbp::OrbitPropagator{Tepoch, T}, vp::AbstractVector{Union{Dates.Period, Dates.CompundPeriod}}, sink = OrbitStateVector; kwargs...) where {Tepoch <: Number, T <: Number} -> Vector{OrbitStateVector{Tepoch, T}}\n\nPropagate the orbit using orbp for every instant defined in vt [s] or for every period defined in vp from the initial orbit epoch. The output type depends on the parameter sink. If it is omitted, it defaults to Tuple, and the output is a tuple with the arrays containing the position and velocity vectors.\n\nKeywords\n\nntasks::Integer: Number of parallel tasks to propagate the orbit. If it is set to a   number equal or lower than 1, the function will propagate the orbit sequentially.   (Default = Threads.nthreads())\n\nReturns\n\nIf sink is Tuple:\n\nVector{SVector{3, T}}: Array with the position vectors [m] in the inertial frame at each   propagation instant defined in vt or vp.\nVector{SVector{3, T}}: Array with the velocity vectors [m / s] in the inertial frame at   each propagation instant defined in vt or vp.\n\nIf sink is OrbitStateVector:\n\nVector{OrbitStateVector{Tepoch, T}}: Array with the orbit state vectors [SI] at each   propagation instant defined in vt or vp.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.Propagators.propagate-Tuple{Val, Union{Dates.CompoundPeriod, Dates.Period}, Vararg{Any}}","page":"Library","title":"SatelliteToolboxPropagators.Propagators.propagate","text":"propagate([sink = Tuple, ]::Val{:propagator}, Δt::Number, args...; kwargs...) -> SVector{3, T}, SVector{3, T}, OrbitPropagator{Tepoch, T}\npropagate([sink = Tuple, ]::Val{:propagator}, p::Union{Dates.Period, Dates.CompundPeriod}, args...; kwargs...) -> SVector{3, T}, SVector{3, T}, OrbitPropagator{Tepoch, T}\npropagate(sink = OrbitStateVector, ::Val{:propagator}, Δt::Number, args...; kwargs...) -> OrbitStateVector{Tepoch, T}, OrbitPropagator{Tepoch, T}\npropagate(sink = OrbitStateVector, ::Val{:propagator}, p::Union{Dates.Period, Dates.CompundPeriod}, args...; kwargs...) -> OrbitStateVector{Tepoch, T}, OrbitPropagator{Tepoch, T}\n\nInitialize the orbit propagator and propagate the orbit by Δt [s] or by the period defined by p from the initial orbit epoch. The initialization arguments args... and kwargs... are the same as in the initialization function Propagators.init. The output type depends on the parameter sink. If it is omitted, it defaults to Tuple and the output is a tuple with the position and velocity vectors.\n\nnote: Note\nT is the propagator number type. For more information, see Propagators.init.\n\nReturns\n\nIf sink is Tuple:\n\nSVector{3, T}: Position vector [m] represented in the inertial frame at propagation   instant.\nSVector{3, T}: Velocity vector [m / s] represented in the inertial frame at propagation   instant.\nOrbitPropagator{Tepoch, T}: Structure with the initialized propagator.\n\nIf sink is OrbitStateVector:\n\nOrbitStateVector{Tepoch, T}: Structure with the orbit state vector [SI] at the   propagation instant.\nOrbitPropagator{Tepoch, T}: Structure with the initialized propagator.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.Propagators.propagate-Union{Tuple{T}, Tuple{Val, AbstractVector{T}, Vararg{Any}}} where T<:Union{Dates.CompoundPeriod, Dates.Period}","page":"Library","title":"SatelliteToolboxPropagators.Propagators.propagate","text":"propagate([sink = Tuple, ]::Val{:propagator}, vt::AbstractVector, args...; kwargs...) -> Vector{SVector{3, T}}, Vector{SVector{3, T}}, OrbitPropagator{Tepoch, T}\npropagate([sink = Tuple, ]::Val{:propagator}, vp::AbstractVector{Union{Dates.Period, Dates.CompundPeriod}}, args...; kwargs...) -> Vector{SVector{3, T}}, Vector{SVector{3, T}}, OrbitPropagator{Tepoch, T}\npropagate(sink = OrbitStateVector, ::Val{:propagator}, vt::AbstractVector, args...; kwargs...) -> Vector{OrbitStateVector{Tepoch, T}}, OrbitPropagator{Tepoch, T}\npropagate(sink = OrbitStateVector, ::Val{:propagator}, vp::AbstractVector{Union{Dates.Period, Dates.CompundPeriod}}, args...; kwargs...) -> Vector{OrbitStateVector{Tepoch, T}}, OrbitPropagator{Tepoch, T}\n\nInitialize the orbit propagator and propagate the orbit for every instant defined in vt [s] or for every period defined in vp from the initial orbit epoch. The initialization arguments args... and kwargs... (except for ntasks) are the same as in the initialization function Propagators.init. The output type depends on the parameter sink. If it is omitted, it defaults to Tuple, and the output is a tuple with the arrays containing the position and velocity vectors.\n\nnote: Note\nT is the propagator number type. For more information, see Propagators.init.\n\nKeywords\n\nntasks::Integer: Number of parallel tasks to propagate the orbit. If it is set to a   number equal or lower than 1, the function will propagate the orbit sequentially.   (Default = Threads.nthreads())\n\nReturns\n\nIf sink is Tuple:\n\nVector{SVector{3, T}}: Array with the position vectors [m] in the inertial frame at each   propagation instant defined in vt or vp.\nVector{SVector{3, T}}: Array with the velocity vectors [m / s] in the inertial frame at   each propagation instant defined in vt or vp.\nOrbitPropagator{Tepoch, T}: Structure with the initialized propagator.\n\nIf sink is OrbitStateVector:\n\nVector{OrbitStateVector{Tepoch, T}}: Array with the orbit state vectors [SI] at each   propagation instant defined in vt or vp.\nOrbitPropagator{Tepoch, T}: Structure with the initialized propagator.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.Propagators.propagate_to_epoch!-Tuple{OrbitPropagator, Dates.DateTime}","page":"Library","title":"SatelliteToolboxPropagators.Propagators.propagate_to_epoch!","text":"propagate_to_epoch!(orbp::OrbitPropagator{Tepoch, T}, jd::Number[, sink = Tuple]) where {Tepoch, T} -> SVector{3, T}, SVector{3, T}\npropagate_to_epoch!(orbp::OrbitPropagator{Tepoch, T}, dt::DateTime[, sink = Tuple]) where {Tepoch, T} -> SVector{3, T}, SVector{3, T}\npropagate_to_epoch!(orbp::OrbitPropagator{Tepoch, T}, jd::Number, sink = OrbitStateVector) where {Tepoch, T} -> OrbitStateVector{Tepoch, T}\npropagate_to_epoch!(orbp::OrbitPropagator{Tepoch, T}, dt::DateTime, sink = OrbitStateVector) where {Tepoch, T} -> OrbitStateVector{Tepoch, T}\n\nPropagate the orbit using orbp until the epoch defined either by the Julian Day jd [UTC] or by the DateTime object dt [UTC]. The output type depends on the parameter sink. If it is omitted, it defaults to Tuple and the output is a tuple with the position and velocity vectors.\n\nReturns\n\nIf sink is Tuple:\n\nSVector{3, T}: Position vector [m] represented in the inertial frame at propagation   instant.\nSVector{3, T}: Velocity vector [m / s] represented in the inertial frame at propagation   instant.\n\nIf sink is OrbitStateVector:\n\nOrbitStateVector{Tepoch, T}: Structure with the orbit state vector [SI] at the   propagation instant.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.Propagators.propagate_to_epoch!-Union{Tuple{T}, Tuple{OrbitPropagator, AbstractVector{T}}} where T<:Dates.DateTime","page":"Library","title":"SatelliteToolboxPropagators.Propagators.propagate_to_epoch!","text":"propagate_to_epoch!(orbp::OrbitPropagator{Tepoch, T}, vjd::AbstractVector[, sink = Tuple]; kwargs...) where {Tepoch, T} -> Vector{SVector{3, T}}, Vector{SVector{3, T}}\npropagate_to_epoch!(orbp::OrbitPropagator{Tepoch, T}, vdt::AbstractVector{DateTime}[, sink = Tuple]; kwargs...) where {Tepoch, T} -> Vector{SVector{3, T}}, Vector{SVector{3, T}}\npropagate_to_epoch!(orbp::OrbitPropagator{Tepoch, T}, vjd::AbstractVector, sink = OrbitStateVector; kwargs...) where {Tepoch, T} -> Vector{OrbitStateVector{Tepoch, T}}\npropagate_to_epoch!(orbp::OrbitPropagator{Tepoch, T}, vdt::AbstractVector{DateTime}, sink = OrbitStateVector; kwargs...) where {Tepoch, T} -> Vector{OrbitStateVector{Tepoch, T}}\n\nPropagate the orbit using orbp for every epoch defined in the vector of Julian Days vjd [UTC] or in the vector of DateTime objects vdt [UTC]. The output type depends on the parameter sink. If it is omitted, it defaults to Tuple, and the output is a tuple with the arrays containing the position and velocity vectors.\n\nKeywords\n\nntasks::Integer: Number of parallel tasks to propagate the orbit. If it is set to a   number equal or lower than 1, the function will propagate the orbit sequentially.   (Default = Threads.nthreads())\n\nReturns\n\nIf sink is Tuple:\n\nVector{SVector{3, T}}: Array with the position vectors [m] in the inertial frame at each   propagation instant defined in vjd or vdt.\nVector{SVector{3, T}}: Array with the velocity vectors [m / s] in the inertial frame at   each propagation instant defined in vjd or vdt.\n\nIf sink is OrbitStateVector:\n\nVector{OrbitStateVector{Tepoch, T}}: Array with the orbit state vectors [SI] at each   propagation instant defined in vjd or vdt.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.Propagators.propagate_to_epoch-Tuple{Val, Dates.DateTime, Vararg{Any}}","page":"Library","title":"SatelliteToolboxPropagators.Propagators.propagate_to_epoch","text":"propagate_to_epoch([sink = Tuple, ]::Val{:propagator}, jd::Number, args...; kwargs...) -> SVector{3, T}, SVector{3, T}, OrbitPropagator{Tepoch, T}\npropagate_to_epoch([sink = Tuple, ]::Val{:propagator}, dt::DateTime, args...; kwargs...) -> SVector{3, T}, SVector{3, T}, OrbitPropagator{Tepoch, T}\npropagate_to_epoch(sink = OrbitStateVector, ::Val{:propagator}, jd::Number, args...; kwargs...) -> OrbitStateVector{Tepoch, T}, OrbitPropagator{Tepoch, T}\npropagate_to_epoch(sink = OrbitStateVector, ::Val{:propagator}, dt::DateTime, args...; kwargs...) -> OrbitStateVector{Tepoch, T}, OrbitPropagator{Tepoch, T}\n\nInitialize the orbit propagator and propagate the orbit until the epoch defined by either the Julian Day jd [UTC] or by a DateTime object dt [UTC] from the initial orbit epoch. The initialization arguments args... and kwargs... are the same as in the initialization function Propagators.init. The output type depends on the parameter sink. If it is omitted, it defaults to Tuple and the output is a tuple with the position and velocity vectors.\n\nnote: Note\nT is the propagator number type. For more information, see Propagators.init.\n\nReturns\n\nIf sink is Tuple:\n\nSVector{3, T}: Position vector [m] represented in the inertial frame at propagation   instant.\nSVector{3, T}: Velocity vector [m / s] represented in the inertial frame at propagation   instant.\nOrbitPropagator{Tepoch, T}: Structure with the initialized propagator.\n\nIf sink is OrbitStateVector:\n\nOrbitStateVector{Tepoch, T}: Structure with the orbit state vector [SI] at the   propagation instant.\nOrbitPropagator{Tepoch, T}: Structure with the initialized propagator.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.Propagators.propagate_to_epoch-Union{Tuple{T}, Tuple{Val, AbstractVector{T}, Vararg{Any}}} where T<:Dates.DateTime","page":"Library","title":"SatelliteToolboxPropagators.Propagators.propagate_to_epoch","text":"propagate_to_epoch([sink = Tuple, ]::Val{:propagator}, vjd::AbstractVector, args...; kwargs...) -> Vector{SVector{3, T}}, Vector{SVector{3, T}}, OrbitPropagator{Tepoch, T}\npropagate_to_epoch([sink = Tuple, ]::Val{:propagator}, vdt::DateTime, args...; kwargs...) -> Vector{SVector{3, T}}, Vector{SVector{3, T}}, OrbitPropagator{Tepoch, T}\npropagate_to_epoch(sink = OrbitStateVector, ::Val{:propagator}, vjd::AbstractVector, args...; kwargs...) -> OrbitStateVector{Tepoch, T}, OrbitPropagator{Tepoch, T}\npropagate_to_epoch(sink = OrbitStateVector, ::Val{:propagator}, vdt::DateTime, args...; kwargs...) -> OrbitStateVector{Tepoch, T}, OrbitPropagator{Tepoch, T}\n\nInitialize the orbit propagator and propagate the orbit for every epoch defined in the vector of Julian Days vjd [UTC] or in the vector of DateTime objects vdt [UTC]. The initialization arguments args... and kwargs... (except for ntasks) are the same as in the initialization function Propagators.init. The output type depends on the parameter sink. If it is omitted, it defaults to Tuple, and the output is a tuple with the arrays containing the position and velocity vectors.\n\nnote: Note\nT is the propagator number type. For more information, see Propagators.init.\n\nKeywords\n\nntasks::Integer: Number of parallel tasks to propagate the orbit. If it is set to a   number equal or lower than 1, the function will propagate the orbit sequentially.   (Default = Threads.nthreads())\n\nReturns\n\nIf sink is Tuple:\n\nVector{SVector{3, T}}: Array with the position vectors [m] in the inertial frame at each   propagation instant defined in vjd or vdt.\nVector{SVector{3, T}}: Array with the velocity vectors [m / s] in the inertial frame at   each propagation instant defined in vjd or vdt.\nOrbitPropagator{Tepoch, T}: Structure with the initialized parameters.\n\nIf sink is OrbitStateVector:\n\nVector{OrbitStateVector{Tepoch, T}}: Array with the orbit state vectors [SI] at each   propagation instant defined in vjd or vdt.\nOrbitPropagator{Tepoch, T}: Structure with the initialized parameters.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolboxPropagators.Propagators.step!-Tuple{OrbitPropagator, Union{Dates.CompoundPeriod, Dates.Period}}","page":"Library","title":"SatelliteToolboxPropagators.Propagators.step!","text":"step!(orbp::OrbitPropagator{Tepoch, T}, Δt::Number[, sink = Tuple]) where {Tepoch, T} -> SVector{3, T}, SVector{3, T}\nstep!(orbp::OrbitPropagator{Tepoch, T}, p::Union{Dates.Period, Dates.CompoundPeriod}[, sink = Tuple]) where {Tepoch, T} -> SVector{3, T}, SVector{3, T}\nstep!(orbp::OrbitPropagator{Tepoch, T}, Δt::Number, sink = OrbitStateVector) where {Tepoch, T} -> OrbitStateVector{Tepoch, T}\nstep!(orbp::OrbitPropagator{Tepoch, T}, p::Union{Dates.Period, Dates.CompoundPeriod}, sink = OrbitStateVector) where {Tepoch, T} -> OrbitStateVector{Tepoch, T}\n\nPropagate the orbit using orbp by Δt [s] or by the period defined by p from the current orbit epoch. The output type depends on the parameter sink. If it is omitted, it defaults to Tuple and the output is a tuple with the position and velocity vectors.\n\nReturns\n\nIf sink is Tuple:\n\nSVector{3, T}: Position vector [m] represented in the inertial frame at propagation   instant.\nSVector{3, T}: Velocity vector [m / s] represented in the inertial frame at propagation   instant.\n\nIf sink is OrbitStateVector:\n\nOrbitStateVector{Tepoch, T}: Structure with the orbit state vector [SI] at the   propagation instant.\n\n\n\n\n\n","category":"method"},{"location":"man/propagators/j2osc/#J2-Osculating-Analytical-Orbit-Propagator","page":"J2 Osculating","title":"J2 Osculating Analytical Orbit Propagator","text":"","category":"section"},{"location":"man/propagators/j2osc/","page":"J2 Osculating","title":"J2 Osculating","text":"CurrentModule = SatelliteToolboxPropagators","category":"page"},{"location":"man/propagators/j2osc/","page":"J2 Osculating","title":"J2 Osculating","text":"using SatelliteToolboxPropagators","category":"page"},{"location":"man/propagators/j2osc/","page":"J2 Osculating","title":"J2 Osculating","text":"This algorithm uses the J2 propagator to obtain the secular effects of the Keplerian elements caused only by the J2 term of the geopotential field. Afterward, it adds short-term perturbations. This model is useful when fitting an orbit to a set of mean elements for the J2 orbit propagator. Hence, we can use it to verify, for example, how close a satellite is from a Sun-Synchronous orbit.","category":"page"},{"location":"man/propagators/j2osc/#Algorithm","page":"J2 Osculating","title":"Algorithm","text":"","category":"section"},{"location":"man/propagators/j2osc/","page":"J2 Osculating","title":"J2 Osculating","text":"The algorithm implemented here is based on [1].","category":"page"},{"location":"man/propagators/j2osc/#Initialization","page":"J2 Osculating","title":"Initialization","text":"","category":"section"},{"location":"man/propagators/j2osc/","page":"J2 Osculating","title":"J2 Osculating","text":"We can initialize the J2 osculating analytical orbit propagator with the following function:","category":"page"},{"location":"man/propagators/j2osc/","page":"J2 Osculating","title":"J2 Osculating","text":"Propagators.init(Val(:J2osc), orb₀::KeplerianElements; kwargs...) -> OrbitPropagatorJ2Osculating","category":"page"},{"location":"man/propagators/j2osc/","page":"J2 Osculating","title":"J2 Osculating","text":"which creates a J2 osculating propagator structure OrbitPropagatorJ2Osculating with the mean Keplerian elements orb₀.","category":"page"},{"location":"man/propagators/j2osc/","page":"J2 Osculating","title":"J2 Osculating","text":"The following keyword selects the gravitational constants for the propagation algorithm:","category":"page"},{"location":"man/propagators/j2osc/","page":"J2 Osculating","title":"J2 Osculating","text":"j2c::J2PropagatorConstants: J2 orbit propagator constants (see J2PropagatorConstants). (Default = j2c_egm2008)","category":"page"},{"location":"man/propagators/j2osc/","page":"J2 Osculating","title":"J2 Osculating","text":"This package contains some pre-built propagation constants for this propagator:","category":"page"},{"location":"man/propagators/j2osc/","page":"J2 Osculating","title":"J2 Osculating","text":"J2 Propagator Constant Description Type\nj2c_egm2008 EGM-2008 gravitational constants Float64\nj2c_egm2008_f32 EGM-2008 gravitational constants Float32\nj2c_egm1996 EGM-1996 gravitational constants Float64\nj2c_egm1996_f32 EGM-1996 gravitational constants Float32\nj2c_jgm02 JGM-02 gravitational constants Float64\nj2c_jgm02_f32 JGM-02 gravitational constants Float32\nj2c_jgm03 JGM-03 gravitational constants Float64\nj2c_jgm03_f32 JGM-03 gravitational constants Float32","category":"page"},{"location":"man/propagators/j2osc/","page":"J2 Osculating","title":"J2 Osculating","text":"note: Note\nThe type used in the propagation will be the same as used to define the constants in the structure j2c.","category":"page"},{"location":"man/propagators/j2osc/","page":"J2 Osculating","title":"J2 Osculating","text":"orb = KeplerianElements(\n    date_to_jd(2023, 1, 1, 0, 0, 0),\n    7190.982e3,\n    0.001111,\n    98.405 |> deg2rad,\n    100    |> deg2rad,\n    90     |> deg2rad,\n    19     |> deg2rad\n)\n\norbp = Propagators.init(Val(:J2osc), orb)","category":"page"},{"location":"man/propagators/j2osc/#Fitting-Mean-Elements","page":"J2 Osculating","title":"Fitting Mean Elements","text":"","category":"section"},{"location":"man/propagators/j2osc/","page":"J2 Osculating","title":"J2 Osculating","text":"We can use the function:","category":"page"},{"location":"man/propagators/j2osc/","page":"J2 Osculating","title":"J2 Osculating","text":"Propagators.fit_mean_elements(::Val{:J2osc}, vjd::AbstractVector{Tjd}, vr_i::AbstractVector{Tv}, vv_i::AbstractVector{Tv}; kwargs...) -> KeplerianElements{Float64, Float64}, SMatrix{6, 6, Float64}","category":"page"},{"location":"man/propagators/j2osc/","page":"J2 Osculating","title":"J2 Osculating","text":"to fit a set of mean Keplerian elements for the J2 osculating orbit propagator using the osculating elements represented by a set of position vectors vr_i [m] and a set of velocity vectors vv_i [m / s] represented in an inertial reference frame at instants in the array vjd [Julian Day].","category":"page"},{"location":"man/propagators/j2osc/","page":"J2 Osculating","title":"J2 Osculating","text":"It returns the fitted Keplerian elements and the final covariance matrix of the least-square algorithm.","category":"page"},{"location":"man/propagators/j2osc/","page":"J2 Osculating","title":"J2 Osculating","text":"note: Note\nThis algorithm version will allocate a new J2 propagator with the default constants j2c_egm2008. If another set of constants are required, use the function Propagators.fit_mean_elements! instead.","category":"page"},{"location":"man/propagators/j2osc/","page":"J2 Osculating","title":"J2 Osculating","text":"The following keywords are available to configure the fitting process:","category":"page"},{"location":"man/propagators/j2osc/","page":"J2 Osculating","title":"J2 Osculating","text":"atol::Number: Tolerance for the residue absolute value. If the residue is lower than   atol at any iteration, the computation loop stops.   (Default = 2e-4)\nrtol::Number: Tolerance for the relative difference between the residues. If the   relative difference between the residues in two consecutive iterations is lower than   rtol, the computation loop stops.   (Default = 2e-4)\ninitial_guess::Union{Nothing, KeplerianElements}: Initial guess for the mean elements   fitting process. If it is nothing, the algorithm will obtain an initial estimate from   the osculating elements in vr_i and vv_i.   (Default = nothing)\njacobian_perturbation::Number: Initial state perturbation to compute the   finite-difference when calculating the Jacobian matrix.   (Default = 1e-3)\njacobian_perturbation_tol::Number: Tolerance to accept the perturbation when calculating   the Jacobian matrix. If the computed perturbation is lower than   jacobian_perturbation_tol, we increase it until it absolute value is higher than   jacobian_perturbation_tol.   (Default = 1e-7)\nmax_iterations::Int: Maximum number of iterations allowed for the least-square fitting.   (Default = 50)\nmean_elements_epoch::Number: Epoch for the fitted mean elements.   (Default = vjd[end])\nverbose::Bool: If true, the algorithm prints debugging information to stdout.   (Default = true)\nweight_vector::AbstractVector: Vector with the measurements weights for the least-square   algorithm. We assemble the weight matrix W as a diagonal matrix with the elements in   weight_vector at its diagonal.   (Default = @SVector(ones(Bool, 6)))","category":"page"},{"location":"man/propagators/j2osc/","page":"J2 Osculating","title":"J2 Osculating","text":"vr_i = [\n    [-6792.402703741442, 2192.6458461287293, 0.18851758695295118] .* 1000,\n    [-6357.88873265975, 2391.9476768911686, 2181.838771262736] .* 1000\n];\n\nvv_i = [\n    [0.3445760107690598, 1.0395135806993514, 7.393686131436984] .* 1000,\n    [2.5285015912807003, 0.27812476784300005, 7.030323100703928] .* 1000\n];\n\nvjd = [\n    2.46002818657856e6,\n    2.460028190050782e6\n];\n\norb, P = Propagators.fit_mean_elements(Val(:J2), vjd, vr_i, vv_i)\n\norb","category":"page"},{"location":"man/propagators/j2osc/#References","page":"J2 Osculating","title":"References","text":"","category":"section"},{"location":"man/propagators/j2osc/","page":"J2 Osculating","title":"J2 Osculating","text":"[1] Vallado, D. A (2013). Fundamentals of Astrodynamics and Applications. 4th ed. Microcosm Press, Hawthorn, CA, USA.","category":"page"},{"location":"man/propagators/j4osc/#J4-Osculating-Analytical-Orbit-Propagator","page":"J4 Osculating","title":"J4 Osculating Analytical Orbit Propagator","text":"","category":"section"},{"location":"man/propagators/j4osc/","page":"J4 Osculating","title":"J4 Osculating","text":"CurrentModule = SatelliteToolboxPropagators","category":"page"},{"location":"man/propagators/j4osc/","page":"J4 Osculating","title":"J4 Osculating","text":"using SatelliteToolboxPropagators","category":"page"},{"location":"man/propagators/j4osc/","page":"J4 Osculating","title":"J4 Osculating","text":"This algorithm uses the J4 propagator to obtain the secular effects of the Keplerian elements caused by the terms J_2, J_2^2, and J_4of the geopotential field. Afterward, it adds short-term perturbations using only the J_2 term. This model is useful when fitting an orbit to a set of mean elements for the J4 orbit propagator.","category":"page"},{"location":"man/propagators/j4osc/#Algorithm","page":"J4 Osculating","title":"Algorithm","text":"","category":"section"},{"location":"man/propagators/j4osc/","page":"J4 Osculating","title":"J4 Osculating","text":"The algorithm implemented here is based on [1].","category":"page"},{"location":"man/propagators/j4osc/#Initialization","page":"J4 Osculating","title":"Initialization","text":"","category":"section"},{"location":"man/propagators/j4osc/","page":"J4 Osculating","title":"J4 Osculating","text":"We can initialize the J4 osculating analytical orbit propagator with the following function:","category":"page"},{"location":"man/propagators/j4osc/","page":"J4 Osculating","title":"J4 Osculating","text":"Propagators.init(Val(:J4osc), orb₀::KeplerianElements; kwargs...) -> OrbitPropagatorJ4Osculating","category":"page"},{"location":"man/propagators/j4osc/","page":"J4 Osculating","title":"J4 Osculating","text":"which creates a J4 osculating propagator structure OrbitPropagatorJ4Osculating with the mean Keplerian elements orb₀.","category":"page"},{"location":"man/propagators/j4osc/","page":"J4 Osculating","title":"J4 Osculating","text":"The following keyword selects the gravitational constants for the propagation algorithm:","category":"page"},{"location":"man/propagators/j4osc/","page":"J4 Osculating","title":"J4 Osculating","text":"j4c::J4PropagatorConstants: J4 orbit propagator constants (see J4PropagatorConstants). (Default = j4c_egm2008)","category":"page"},{"location":"man/propagators/j4osc/","page":"J4 Osculating","title":"J4 Osculating","text":"This package contains some pre-built propagation constants for this propagator:","category":"page"},{"location":"man/propagators/j4osc/","page":"J4 Osculating","title":"J4 Osculating","text":"J4 Propagator Constant Description Type\nj4c_egm2008 EGM-2008 gravitational constants Float64\nj4c_egm2008_f32 EGM-2008 gravitational constants Float32\nj4c_egm1996 EGM-1996 gravitational constants Float64\nj4c_egm1996_f32 EGM-1996 gravitational constants Float32\nj4c_jgm02 JGM-02 gravitational constants Float64\nj4c_jgm02_f32 JGM-02 gravitational constants Float32\nj4c_jgm03 JGM-03 gravitational constants Float64\nj4c_jgm03_f32 JGM-03 gravitational constants Float32","category":"page"},{"location":"man/propagators/j4osc/","page":"J4 Osculating","title":"J4 Osculating","text":"note: Note\nThe type used in the propagation will be the same as used to define the constants in the structure j4c.","category":"page"},{"location":"man/propagators/j4osc/","page":"J4 Osculating","title":"J4 Osculating","text":"orb = KeplerianElements(\n           date_to_jd(2023, 1, 1, 0, 0, 0),\n           7190.982e3,\n           0.001111,\n           98.405 |> deg2rad,\n           100    |> deg2rad,\n           90     |> deg2rad,\n           19     |> deg2rad\n       )\n\norbp = Propagators.init(Val(:J4osc), orb)","category":"page"},{"location":"man/propagators/j4osc/#Fitting-Mean-Elements","page":"J4 Osculating","title":"Fitting Mean Elements","text":"","category":"section"},{"location":"man/propagators/j4osc/","page":"J4 Osculating","title":"J4 Osculating","text":"We can use the function:","category":"page"},{"location":"man/propagators/j4osc/","page":"J4 Osculating","title":"J4 Osculating","text":"Propagators.fit_mean_elements(::Val{:J4osc}, vjd::AbstractVector{Tjd}, vr_i::AbstractVector{Tv}, vv_i::AbstractVector{Tv}; kwargs...) -> KeplerianElements{Float64, Float64}, SMatrix{6, 6, Float64}","category":"page"},{"location":"man/propagators/j4osc/","page":"J4 Osculating","title":"J4 Osculating","text":"to fit a set of mean Keplerian elements for the J4 osculating orbit propagator using the osculating elements represented by a set of position vectors vr_i [m] and a set of velocity vectors vv_i [m / s] represented in an inertial reference frame at instants in the array vjd [Julian Day].","category":"page"},{"location":"man/propagators/j4osc/","page":"J4 Osculating","title":"J4 Osculating","text":"It returns the fitted Keplerian elements and the final covariance matrix of the least-square algorithm.","category":"page"},{"location":"man/propagators/j4osc/","page":"J4 Osculating","title":"J4 Osculating","text":"note: Note\nThis algorithm version will allocate a new J4 propagator with the default constants j4c_egm2008. If another set of constants are required, use the function Propagators.fit_mean_elements! instead.","category":"page"},{"location":"man/propagators/j4osc/","page":"J4 Osculating","title":"J4 Osculating","text":"The following keywords are available to configure the fitting process:","category":"page"},{"location":"man/propagators/j4osc/","page":"J4 Osculating","title":"J4 Osculating","text":"atol::Number: Tolerance for the residue absolute value. If the residue is lower than   atol at any iteration, the computation loop stops.   (Default = 2e-4)\nrtol::Number: Tolerance for the relative difference between the residues. If the   relative difference between the residues in two consecutive iterations is lower than   rtol, the computation loop stops.   (Default = 2e-4)\ninitial_guess::Union{Nothing, KeplerianElements}: Initial guess for the mean elements   fitting process. If it is nothing, the algorithm will obtain an initial estimate from   the osculating elements in vr_i and vv_i.   (Default = nothing)\njacobian_perturbation::Number: Initial state perturbation to compute the   finite-difference when calculating the Jacobian matrix.   (Default = 1e-3)\njacobian_perturbation_tol::Number: Tolerance to accept the perturbation when calculating   the Jacobian matrix. If the computed perturbation is lower than   jacobian_perturbation_tol, we increase it until it absolute value is higher than   jacobian_perturbation_tol.   (Default = 1e-7)\nmax_iterations::Int: Maximum number of iterations allowed for the least-square fitting.   (Default = 50)\nmean_elements_epoch::Number: Epoch for the fitted mean elements.   (Default = vjd[end])\nverbose::Bool: If true, the algorithm prints debugging information to stdout.   (Default = true)\nweight_vector::AbstractVector: Vector with the measurements weights for the least-square   algorithm. We assemble the weight matrix W as a diagonal matrix with the elements in   weight_vector at its diagonal.   (Default = @SVector(ones(Bool, 6)))","category":"page"},{"location":"man/propagators/j4osc/","page":"J4 Osculating","title":"J4 Osculating","text":"vr_i = [\n    [-6792.402703741442, 2192.6458461287293, 0.18851758695295118] .* 1000,\n    [-6357.88873265975, 2391.9476768911686, 2181.838771262736] .* 1000\n];\n\nvv_i = [\n    [0.3445760107690598, 1.0395135806993514, 7.393686131436984] .* 1000,\n    [2.5285015912807003, 0.27812476784300005, 7.030323100703928] .* 1000\n];\n\nvjd = [\n    2.46002818657856e6,\n    2.460028190050782e6\n];\n\norb, P = Propagators.fit_mean_elements(Val(:J4), vjd, vr_i, vv_i)\n\norb","category":"page"},{"location":"man/propagators/j4osc/#References","page":"J4 Osculating","title":"References","text":"","category":"section"},{"location":"man/propagators/j4osc/","page":"J4 Osculating","title":"J4 Osculating","text":"[1] Vallado, D. A (2013). Fundamentals of Astrodynamics and Applications. 4th ed. Microcosm Press, Hawthorn, CA, USA.","category":"page"},{"location":"#SatelliteToolboxPropagators.jl","page":"Home","title":"SatelliteToolboxPropagators.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This packages contains orbit propagators for the SatelliteToolbox.jl ecosystem.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The current supported propagators are:","category":"page"},{"location":"","page":"Home","title":"Home","text":"J2 analytical orbit propagator;\nJ2 osculating analytical orbit propagator;\nJ4 analytical orbit propagator;\nJ4 osculating analytical orbit propagator;\nSGP4/SDP4 orbit propagator; and\nTwo body analytical orbit propagator.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg\njulia> Pkg.install(\"SatelliteToolboxPropagators\")","category":"page"}]
}
